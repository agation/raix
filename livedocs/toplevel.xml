<asdoc>

<classRec name='Projection' fullname='raix.utils:Projection' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\utils\Projection.as' namespace='raix.utils' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Contains common projection functions that can be used with IEnumerable.map 

	 and other 

	 ]]></description>
</classRec>
<method name='property' fullname='raix.utils:Projection/property' isStatic='true' isFinal='false' isOverride='false'  param_names='propertyName' param_types='String' param_defaults='undefined' result_type='Function'>
<description><![CDATA[

		 Returns a selector function that retrieves a property from an element. 

		 ]]></description>
<param><![CDATA[propertyName The property to map from each element

		 ]]></param>
<return><![CDATA[A function that returns the property value of propertyName or null if the element was null

		 ]]></return>
</method>
<method name='toLowerCase' fullname='raix.utils:Projection/toLowerCase/get' isStatic='true' isFinal='false' isOverride='false'  result_type='Function'>
<description><![CDATA[

		 Returns a selector function that converts a string to lower case

		 ]]></description>
<return><![CDATA[A function that returns the string element as lower case or null if the element was null

		 ]]></return>
</method>
<method name='toString' fullname='raix.utils:Projection/toString/get' isStatic='true' isFinal='false' isOverride='false'  result_type='Function'>
<description><![CDATA[

		 Returns a selector function that converts an object to a string

		 ]]></description>
<return><![CDATA[A function that returns the string representation of an element or null if the element was null

		 ]]></return>
</method>
<method name='toUpperCase' fullname='raix.utils:Projection/toUpperCase/get' isStatic='true' isFinal='false' isOverride='false'  result_type='Function'>
<description><![CDATA[

		 Returns a selector function that converts a string to upper case

		 ]]></description>
<return><![CDATA[A function that returns the string element as lower case or null if the element was null

		 ]]></return>
</method>
<classRec name='Filter' fullname='raix.utils:Filter' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\utils\Filter.as' namespace='raix.utils' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='not' fullname='raix.utils:Filter/not' isStatic='true' isFinal='false' isOverride='false'  param_names='inner' param_types='Function' param_defaults='undefined' result_type='Function'>
</method>
<method name='notNull' fullname='raix.utils:Filter/notNull/get' isStatic='true' isFinal='false' isOverride='false'  result_type='Function'>
</method>
<interfaceRec name='IEnumerator' fullname='raix.interactive:IEnumerator' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\IEnumerator.as' namespace='raix.interactive' access='public' baseClasses='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Contains the state of an active enumeration. This interface is rarely accessed 

	 by client code as IEnumerable sequences can be used with `for each`

	 ]]></description>
</interfaceRec>
<method name='moveNext' fullname='raix.interactive:IEnumerator/raix.interactive:IEnumerator:moveNext' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
<description><![CDATA[

		 Moves to the next value in the sequence 

		 ]]></description>
<return><![CDATA[true if a new value is available; false if the end of the sequence has been reacheds

		 ]]></return>
</method>
<method name='current' fullname='raix.interactive:IEnumerator/raix.interactive:IEnumerator:current/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Returns the current value in the sequence

		 ]]></description>
</method>
<classRec name='Comparer' fullname='raix.interactive:Comparer' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\Comparer.as' namespace='raix.interactive' access='internal' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='caseInsensitive' fullname='raix.interactive:Comparer/caseInsensitive' isStatic='true' isFinal='false' isOverride='false'  param_names='l;r' param_types='String;String' param_defaults='undefined;undefined' result_type='int'>
</method>
<method name='compound' fullname='raix.interactive:Comparer/compound' isStatic='true' isFinal='false' isOverride='false'  param_names='primaryComparer;secondaryComparer' param_types='Function;Function' param_defaults='undefined;undefined' result_type='Function'>
</method>
<method name='defaultComparer' fullname='raix.interactive:Comparer/defaultComparer' isStatic='true' isFinal='false' isOverride='false'  param_names='l;r' param_types='Object;Object' param_defaults='undefined;undefined' result_type='int'>
</method>
<method name='projection' fullname='raix.interactive:Comparer/projection' isStatic='true' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;undefined' result_type='Function'>
</method>
<method name='reverse' fullname='raix.interactive:Comparer/reverse' isStatic='true' isFinal='false' isOverride='false'  param_names='forwardComparer' param_types='Function' param_defaults='undefined' result_type='Function'>
</method>
<classRec name='ClosureEnumerator' fullname='raix.interactive:ClosureEnumerator' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\ClosureEnumerator.as' namespace='raix.interactive' access='internal' baseclass='Object' interfaces='raix.interactive:IEnumerator' isFinal='false' isDynamic='false' >
</classRec>
<method name='ClosureEnumerator' fullname='raix.interactive:ClosureEnumerator/ClosureEnumerator' isStatic='false' isFinal='false' isOverride='false'  param_names='moveNextFunc;currentFunc' param_types='Function;Function' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='moveNext' fullname='raix.interactive:ClosureEnumerator/moveNext' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
</method>
<method name='current' fullname='raix.interactive:ClosureEnumerator/current/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
</method>
<field name='_currentFunc' fullname='raix.interactive:ClosureEnumerator/private:_currentFunc' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_moveNextFunc' fullname='raix.interactive:ClosureEnumerator/private:_moveNextFunc' type='Function' isStatic='false' isConst='false' >
</field>
<interfaceRec name='IEnumerable' fullname='raix.interactive:IEnumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\IEnumerable.as' namespace='raix.interactive' access='public' baseClasses='raix.reactive:ICancelable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a collection of values which can be enumerated using foreach, but 

	 does not support random access

	 ]]></description>
</interfaceRec>
<method name='all' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:all' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='Boolean'>
<description><![CDATA[

		 Determines if the every value in the source sequence matches a predicate 

		 function.

		 

		 Uses immediate execution and stops enumerating when a negative match is found.

		 ]]></description>
<param><![CDATA[predicate (optional) A function in the format: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[true if the sequence is empty or all the values in the sequence match the predicate; 

		         false otherwise

		 ]]></return>
</method>
<method name='any' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:any' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Boolean'>
<description><![CDATA[

		 Determines if the predicate argument function returns true for any 

		 item in the sequence. If no function is supplied, true will be returned 

		 if the sequence contains any values 

		 

		 Uses immediate execution and stops enumerating when a match is found. 

		 ]]></description>
<param><![CDATA[predicate (optional) A function in the format: function(element : TElement) : Boolean 

		 ]]></param>
<return><![CDATA[true if a matching value is found or if predicate is null and the

		              sequence contains any values; false otherwise

		 ]]></return>
</method>
<method name='average' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:average' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='Number'>
<description><![CDATA[

		 Retrieves the average value in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty.

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the numeric value of the element 

		 ]]></param>
<return><![CDATA[The average value of the sequence

		 ]]></return>
</method>
<method name='concat' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:concat' isStatic='false' isFinal='false' isOverride='false'  param_names='second' param_types='raix.interactive:IEnumerable' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that will seemlessly enumerate a second sequence after 

		 the first sequence completes

		 ]]></description>
<param><![CDATA[second The sequence to enumerate after the first sequence

		 ]]></param>
<return><![CDATA[A new sequence that contains the values from the first and second sequence, in order

		 ]]></return>
</method>
<method name='contains' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:contains' isStatic='false' isFinal='false' isOverride='false'  param_names='value;equalityComparer' param_types='Object;Function' param_defaults='undefined;null' result_type='Boolean'>
<description><![CDATA[

		 Determines if the source sequence contains a specific value, optionally 

		 using an equalityComparer function.

		 

		 Uses immediate execution and stops enumerating when a match is found

		 ]]></description>
<param><![CDATA[value The value to be compared

		 ]]></param>
<param><![CDATA[equalityComparer (optional) A function to compare two 

		        values: function(x : TElement, y : TValue) : Boolean 

		 ]]></param>
<return><![CDATA[true if a match was found; false otherwise

		 ]]></return>
</method>
<method name='count' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:count' isStatic='false' isFinal='false' isOverride='false'  result_type='uint'>
<description><![CDATA[

		 Determines the number of elements in the sequence. Uses immediate execution.

		 ]]></description>
<return><![CDATA[The number of elements in the sequence

		 ]]></return>
</method>
<method name='defaultIfEmpty' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:defaultIfEmpty' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue' param_types='Object' param_defaults='null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that will return the given defaultValue 

		 

		 Uses deferred execution

		 ]]></description>
<param><![CDATA[defaultValue (optional) The default value to use if the sequence is empty. 

		        If not supplied, the value will be converted from null (int = 0, boolean = false, etc)

		 ]]></param>
<return><![CDATA[A new IEnumerable sequence

		 ]]></return>
</method>
<method name='distinct' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:distinct' isStatic='false' isFinal='false' isOverride='false'  param_names='hashSelector' param_types='Function' param_defaults='null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that only contains the unique values in the original sequence.

		 

		 If the sequence contains values that are not natively comparable (String, u/int, Number, Boolean),

		 a hashSelector should be specified to return a value that is. An example of this would be to return 

		 the ID property of an entity.

		 

		 Uses deferred execution

		 ]]></description>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		        function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence that contains the distinct values of the original sequence

		 ]]></return>
</method>
<method name='elementAtOrDefault' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:elementAtOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='index;defaultValue' param_types='int;Object' param_defaults='undefined;null' result_type='Object'>
<description><![CDATA[

		 Returns the element at the given index or a default value if 

		 the sequence does not contain that many elements. 

		 ]]></description>
<param><![CDATA[index The zero-based index of the value to return

		 ]]></param>
<return><![CDATA[The value at index

		 ]]></return>
<defaultValue><![CDATA[The value to return if the sequence does not contain (index+1) elements

		 ]]></defaultValue>
</method>
<method name='elementAt' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:elementAt' isStatic='false' isFinal='false' isOverride='false'  param_names='index' param_types='int' param_defaults='undefined' result_type='Object'>
<description><![CDATA[

		 Returns the element at the given index or throws an IllegalOperationError if 

		 the sequence does not contain that many elements. 

		 ]]></description>
<param><![CDATA[index The zero-based index of the value to return

		 ]]></param>
<return><![CDATA[The value at index

		 ]]></return>
</method>
<method name='except' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:except' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that contains the values in the source sequence that 

		 do not exist in the supplied sequence

		 

		 ]]></description>
<param><![CDATA[right The right side of the except. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the values contained in the source sequence but 

		         not the "right" sequence 

		 ]]></return>
<see><![CDATA[raix.interactive.toEnumerable

		 ]]></see>
</method>
<method name='filter' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:filter' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Filters the source sequence based on a predicate function. Uses deferred execution.

		 ]]></description>
<param><![CDATA[predicate A function that determines which elements should appear in the result:

		     function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[A sequence that contains values from the source sequence for which predicate returned true

		 ]]></return>
</method>
<method name='firstOrDefault' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:firstOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 Returns the first element in the sequence or returns a default value 

		 if the sequence is empty. If predicate is supplied, the first value to match the 

		 predicate will be returned with the default value being returned if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='first' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:first' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence is empty. If predicate is supplied, the first value to match the 

		 predicate will be returned with an IllegalOperationError being thrown if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first value in the sequence or the first value in the sequence that matches predicate

		 ]]></return>
</method>
<method name='getEnumerator' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:getEnumerator' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.interactive:IEnumerator'>
<description><![CDATA[

		 Returns an object that can be used to enumerate through this sequence. Access to this method 

		 is not generally required as IEnumerable sequence 

		 ]]></description>
<return><![CDATA[An IEnumerator 

		 ]]></return>
</method>
<method name='groupBy' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:groupBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyHashSelector' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Groups elements of a sequence using a key selector function

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for a value in the sequence:

		     function(source : TSource) : TKey

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, maps the source element to an element 

		     to place in the grouping: function(source : TSource) : TElement

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) If specified, returns a natively comparable value

		     for a key in the sequence: function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type IGrouping, where each IGrouping is a sequence 

		     of values of type TElement and a key

		 ]]></return>
</method>
<method name='groupJoin' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:groupJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='inner;outerKeySelector;innerKeySelector;resultSelector;keyHashSelector' param_types='raix.interactive:IEnumerable;Function;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Correlates the elements of two sequences based on keys and groups the results

		 

		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 

		 sequence

		 

		 ]]></description>
<param><![CDATA[inner The sequence to join to the first sequence. Can be any value that can be converted 

		     to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[outerKeySelector Retrieves the key from values in the outer (source) sequence:

		     function(element : TOuterElement) : TKey 

		 ]]></param>
<param><![CDATA[innerKeySelector Retrieves the key from values in the inner sequence:

		     function(element : TInnerElement) : TKey

		 ]]></param>
<param><![CDATA[resultSelector Creates a result element from the source sequence and a sequnce of 

		     matching values from the inner sequence:

		     function(outer : TOuterElement, inner : IEnumerable.&lt;TInnerElement&gt;) : TResult

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) Returns a natively comparable value for a key:

		     function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type TResult that are obtained by joining outer and inner

		     sequences.

		 ]]></return>
<see><![CDATA[raix.interactive.toEnumerable

		 ]]></see>
</method>
<method name='intersect' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:intersect' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that contains only the values contained in both sequences

		 

		 ]]></description>
<param><![CDATA[right The right side of the intersection. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the unique values contained in both sequence 

		 ]]></return>
<see><![CDATA[raix.interactive.toEnumerable

		 ]]></see>
</method>
<method name='join' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:join' isStatic='false' isFinal='false' isOverride='false'  param_names='inner;outerKeySelector;innerKeySelector;resultSelector;keyHashSelector' param_types='raix.interactive:IEnumerable;Function;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Correlates the elements of two sequences based on keys.

		 

		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 

		 sequence

		 

		 ]]></description>
<param><![CDATA[inner The sequence to join to the first sequence. Can be any value that can be converted 

		     to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[outerKeySelector Retrieves the key from values in the outer (source) sequence:

		     function(element : TOuterElement) : TKey 

		 ]]></param>
<param><![CDATA[innerKeySelector Retrieves the key from values in the inner sequence:

		     function(element : TInnerElement) : TKey

		 ]]></param>
<param><![CDATA[resultSelector Creates a result element from two matching elements:

		     function(outer : TOuterElement, inner : TInnerElement) : TResult

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) Returns a natively comparable value for a key:

		     function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type TResult that are obtained by joining outer and inner

		     sequences.

		 ]]></return>
<see><![CDATA[raix.interactive.toEnumerable

		 ]]></see>
</method>
<method name='lastOrDefault' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:lastOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 Returns the last element in the sequence or returns a default value 

		 if the sequence is empty. If predicate is supplied, the last value to match the 

		 predicate will be returned with the default value being returned if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The last matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='last' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:last' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 Returns the last element in the sequence or throws an IllegalOperationError 

		 if the sequence is empty. If predicate is supplied, the last value to match the 

		 predicate will be returned with an IllegalOperationError being thrown if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The last matching value

		 ]]></return>
</method>
<method name='mapMany' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:mapMany' isStatic='false' isFinal='false' isOverride='false'  param_names='collectionSelector;resultSelector' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Maps a sequence for each value in the source sequence and concatonates the results into 

		 a single sequence. Uses deferred execution.

		 

		 ]]></description>
<param><![CDATA[collectionSelector A function to retrieve the sequence for a value in the source sequence: 

		     function(element : TElement) : IEnumerable.&lt;TCollection>

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that creates a result element from each source element 

		     and each of its enumerated collection values: 

		     function(element : TElement, value : TCollection) : TResult

		 ]]></param>
<return><![CDATA[A sequence that contains values of type TResult if resultSelector is specified, 

		     or TCollection if it is not.

		 ]]></return>
</method>
<method name='map' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:map' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Projects (converts) values using a selector function. Uses deferred execution

		 ]]></description>
<param><![CDATA[selector Projects the values from the source sequence: 

		     function(element : TElement) : TResult

		 ]]></param>
<return><![CDATA[A new sequence that contains the projected values of type TResult

		 ]]></return>
</method>
<method name='max' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:max' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector;comparer' param_types='Function;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 Retrieves the maximum element in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty.

		 

		 If the comparison value (either the original element or the value returned by valueSelector)

		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 

		 to compare the values

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the value to be 

		        compared for each element in the sequence: function(element : TElement) : TValue

		 ]]></param>
<param><![CDATA[comparer (optional) If specified, compares the value (either element 

		        value or the value returned by valueSelector): 

		        function(value : TValue) : int

		 ]]></param>
<return><![CDATA[The sequence element deemed to be the maximum value

		 ]]></return>
</method>
<method name='min' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:min' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector;comparer' param_types='Function;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 Retrieves the minimum element in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty

		 

		 If the comparison value (either the original element or the value returned by valueSelector)

		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 

		 to compare the values

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the value to be 

		        compared for each element in the sequence: function(element : TElement) : TValue

		 ]]></param>
<param><![CDATA[comparer (optional) If specified, compares the value (either element 

		        value or the value returned by valueSelector): 

		        function(value : TValue) : int

		 ]]></param>
<return><![CDATA[The sequence element deemed to be the minimum value

		 ]]></return>
</method>
<method name='ofType' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:ofType' isStatic='false' isFinal='false' isOverride='false'  param_names='cls' param_types='Class' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Filters values from a sequence based on their type

		 ]]></description>
<param><![CDATA[cls A class on which to filter values from the source sequence.

		 ]]></param>
<return><![CDATA[A sequence that contains only elements from the source sequence that are of type 

		     cls (or a subclass)

		 ]]></return>
</method>
<method name='orderByDescending' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:orderByDescending' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 Orders the values in the source sequence in descending order

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
<see><![CDATA[raix.interactive.IOrderedObservable

		 ]]></see>
</method>
<method name='orderBy' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:orderBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 Orders the values in the source sequence in ascending order

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
<see><![CDATA[raix.interactive.IOrderedObservable

		 ]]></see>
</method>
<method name='reduce' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:reduce' isStatic='false' isFinal='false' isOverride='false'  param_names='seed;accumulator;resultSelector' param_types='Object;Function;Function' param_defaults='undefined;undefined;null' result_type='Object'>
<description><![CDATA[

		 Aggregates values in a sequence using functions passed as arguments.

		 

		 Accumulates a value, starting with seed, by calling accumulator for each value in the source 

		 sequence and using the return value as the new accumulated value. When the sequence completes, 

		 the accumulated value is (optonally) mapped through resultSelector before being returned.

		 ]]></description>
<param><![CDATA[seed The initial value for the accumulation

		 ]]></param>
<param><![CDATA[accumulator A function that returns the new accumulated value: 

		        function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that maps the final accumulate value before being returned

		 ]]></param>
<return><![CDATA[The return value of resultSelector (if supplied) or the final accumulate value if 

		         resultSelector is not supplied

		 ]]></return>
</method>
<method name='repeat' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:repeat' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='0' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Repeats the source sequence a specified number of times 

		 ]]></description>
<param><![CDATA[count (optional) The number of times to repeat the sequence. If 0, the 

		     sequence will be repeated indefinately

		 ]]></param>
<return><![CDATA[A sequence containing values of the same type as the source

		 ]]></return>
</method>
<method name='reverse' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:reverse' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Reverses the values in the source sequence

		 ]]></description>
<return><![CDATA[A new sequence containing the reversed values of the source sequence

		 ]]></return>
</method>
<method name='scan' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:scan' isStatic='false' isFinal='false' isOverride='false'  param_names='seed;accumulator;resultSelector' param_types='Object;Function;Function' param_defaults='undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a sequence that aggregates values using functions passed as arguments, using 

		 deferred execution and returning the values accumulated values as they are returned.

		 

		 Accumulates a value, starting with seed, by calling accumulator for each value in the 

		 source sequence and using the return value as the new accumulated value. Each time  

		 a new value is accumulated, the accumulated value is (optonally) mapped through 

		 resultSelector before being returned.

		 ]]></description>
<param><![CDATA[seed The initial value for the accumulation

		 ]]></param>
<param><![CDATA[accumulator A function that returns the new accumulated value: 

		        function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that maps the final accumulate value before being returned

		 ]]></param>
<return><![CDATA[A sequence of type TAccumulate that can be enumerated

		 ]]></return>
</method>
<method name='sequenceEqual' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:sequenceEqual' isStatic='false' isFinal='false' isOverride='false'  param_names='right;comparer' param_types='raix.interactive:IEnumerable;Function' param_defaults='undefined;null' result_type='Boolean'>
<description><![CDATA[

		 Determines whether two sequences are equal. Uses immediate execution 

		 

		 ]]></description>
<param><![CDATA[right Ths sequence to compare to the source

		 ]]></param>
<param><![CDATA[comparer A function that will determine equality between left and right values:

		     function(left : TLeft, right : TRight) : Boolean

		 ]]></param>
<return><![CDATA[true if the sequences are of equal length and all of their values are equal

		 ]]></return>
</method>
<method name='singleOrDefault' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:singleOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence does contains multiple values, but returns a default value if 

		 the sequence returns no values. If predicate is supplied, the first value to match 

		 the predicate will be returned with an IllegalOperationError 

		 being thrown if the sequence contains more than one match and a default value being 

		 returned if no matches are found

		 ]]></description>
<param><![CDATA[defaultValue A defaultValue to 

		 ]]></param>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='single' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:single' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence does not contain exactly one value. If predicate is supplied, 

		 the first value to match the predicate will be returned with an IllegalOperationError 

		 being thrown if the sequence does not contain exactly one match

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first value in the sequence or the first value in the sequence that matches predicate

		 ]]></return>
</method>
<method name='skipLast' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:skipLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that excludes the specified number of values from 

		 the end of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to skip from the end of source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='skipWhile' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:skipWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that skips values from the source sequence 

		 until a specified predicate returns false, at which point values will be 

		 returned from the rest of sequence 

		 ]]></description>
<param><![CDATA[predicate A function that determines whether values should still be skipped 

		     from the source sequence: function(element:TElement) : Boolean 

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='skip' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:skip' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that excludes the specified number of values from 

		 the start of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to skip from the source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='sum' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:sum' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='Number'>
<description><![CDATA[

		 Returns the total numeric value of every value in the sequence 

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, can be used to specify the numeric 

		        value for each element in the sequence 

		 ]]></param>
<return><![CDATA[The summed values of each element in the sequence

		 ]]></return>
</method>
<method name='takeLast' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:takeLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that includes a maximum number of elements to take from 

		 the end of the first sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to take from the end of source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='takeWhile' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:takeWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that includes values from the source sequence 

		 until a specified predicate returns false, at which point the sequence will end 

		 ]]></description>
<param><![CDATA[predicate A function that determines whether values should still be taken 

		     from the source sequence: function(element:TElement) : Boolean 

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='take' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:take' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that includes a maximum number of elements from the first sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to take from the source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='toArray' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:toArray' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
<description><![CDATA[

		 Retrieves an array containing all the values in the sequence 

		 ]]></description>
<return><![CDATA[An Array containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='toDictionary' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:toDictionary' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector' param_types='Function;Function' param_defaults='undefined;null' result_type='flash.utils:Dictionary'>
<description><![CDATA[

		 Converts the sequence to a Dictionary. Uses immediate execution

		 

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for each element in the sequence

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, provides the "values"  

		     in the lookup. If not specified, the original element will be used

		 ]]></param>
<return><![CDATA[A Dictionary

		 ]]></return>
</method>
<method name='toLookup' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:toLookup' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyHashSelector' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.interactive:ILookup'>
<description><![CDATA[

		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 

		 differences:

		 

		 <ul>

		 <li>Supports null keys</li>

		 <li>Returns an empty sequence for requests for keys that do not exist</li>

		 </ul>

		 

		 Uses immediate execution

		 

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for each element in the sequence

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, provides the "values"  

		     in the lookup. If not specified, the original element will be used

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) If the value returned by keySelector is not natively 

		        comparable (ie. String, u/int, Number, Boolean), keyHashSelector can be used to 

		        provide comparable values for the keys: function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[An ILookup

		 ]]></return>
</method>
<method name='toObservable' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:toObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 

		 ]]></description>
<param><![CDATA[scheduler (optional) The scheduler to use to distribute the values. Defaults to 

		     Scheduler.asynchronous

		 ]]></param>
<return><![CDATA[An observable sequence that contains values of the same type as the source sequence

		 ]]></return>
</method>
<method name='union' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:union' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a new sequence that contains the unique values across two sequences

		 

		 ]]></description>
<param><![CDATA[right The right side of the union. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the distinct values across both sequences 

		 ]]></return>
<see><![CDATA[raix.interactive.toEnumerable

		 ]]></see>
</method>
<method name='zip' fullname='raix.interactive:IEnumerable/raix.interactive:IEnumerable:zip' isStatic='false' isFinal='false' isOverride='false'  param_names='right;resultSelector' param_types='raix.interactive:IEnumerable;Function' param_defaults='undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Pairs values from two sequences in order and uses a selector function to project the results

		 ]]></description>
<param><![CDATA[right The sequence to pair with the left (source) sequence

		 ]]></param>
<param><![CDATA[resultSelector A function to map values from the left and right sequences:

		     function(left : TLeft, right : TRight) : TResult

		 ]]></param>
<return><![CDATA[A sequence containing values of type TResult

		 ]]></return>
</method>
<interfaceRec name='IOrderedEnumerable' fullname='raix.interactive:IOrderedEnumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\IOrderedEnumerable.as' namespace='raix.interactive' access='public' baseClasses='raix.interactive:IEnumerable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An enumerable sequence that has ordering applied to it

	 ]]></description>
</interfaceRec>
<method name='thenByDescending' fullname='raix.interactive:IOrderedEnumerable/raix.interactive:IOrderedEnumerable:thenByDescending' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 Adds a secondary, descending, sort condition to the IOrderedEnumerable

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
<see><![CDATA[raix.interactive.IOrderedObservable

		 ]]></see>
</method>
<method name='thenBy' fullname='raix.interactive:IOrderedEnumerable/raix.interactive:IOrderedEnumerable:thenBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 Adds a secondary sort condition to the IOrderedEnumerable

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
<see><![CDATA[raix.interactive.IOrderedObservable

		 ]]></see>
</method>
<interfaceRec name='IGrouping' fullname='raix.interactive:IGrouping' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\IGrouping.as' namespace='raix.interactive' access='public' baseClasses='raix.interactive:IEnumerable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Contains a list of grouped values and a key identifying the group

	 ]]></description>
<see><![CDATA[IEnumerable.groupBy

	 ]]></see>
</interfaceRec>
<method name='key' fullname='raix.interactive:IGrouping/raix.interactive:IGrouping:key/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Returns the key that identifies this grouping

		 ]]></description>
</method>
<interfaceRec name='ILookup' fullname='raix.interactive:ILookup' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\ILookup.as' namespace='raix.interactive' access='public' baseClasses='raix.interactive:IEnumerable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Contains values grouped by keys

	 ]]></description>
<see><![CDATA[IEnumerable.toLookup

	 ]]></see>
</interfaceRec>
<method name='containsKey' fullname='raix.interactive:ILookup/raix.interactive:ILookup:containsKey' isStatic='false' isFinal='false' isOverride='false'  param_names='key' param_types='Object' param_defaults='undefined' result_type='Boolean'>
</method>
<method name='getValues' fullname='raix.interactive:ILookup/raix.interactive:ILookup:getValues' isStatic='false' isFinal='false' isOverride='false'  param_names='key' param_types='Object' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Returns a sequence of values for the specified key or 

		 an empty sequence if the key has no values 

		 ]]></description>
<param><![CDATA[key The key to lookup

		 ]]></param>
<return><![CDATA[An IEnumerable sequence of values

		 ]]></return>
</method>
<method name='toEnumerable' fullname='raix.interactive:toEnumerable' isStatic='false' isFinal='false' isOverride='false'  param_names='args' param_types='restParam' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

	 Converts a value to an IEnumerable sequence. It can be considered to have the following overloads:

	 

	 <ul>

	 <li>function():IEnumerable - returns an empty sequence</li>

	 <li>function(array : Array):IEnumerable - returns a sequence that wraps an array</li>

	 <li>function(enumerable : IEnumerable):IEnumerable - returns enumerable</li>

	 <li>function(proxy : Proxy):IEnumerable - returns enumerable that wraps an enumerable Proxy</li>

	 <li>function(value : :IEnumerable - returns enumerable that contains a single value</li>

	 </ul>

	 ]]></description>
</method>
<classRec name='Enumerable' fullname='raix.interactive:Enumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\Enumerable.as' namespace='raix.interactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Provides static methods that create IEnumerable sequences

	 ]]></description>
</classRec>
<method name='create' fullname='raix.interactive:Enumerable/create' isStatic='true' isFinal='false' isOverride='false'  param_names='moveNext;getCurrent' param_types='Function;Function' param_defaults='undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an enumerable sequence that uses callbacks 

		 ]]></description>
<param><![CDATA[moveNext Moves to the next item in the sequence, returning false when no more items exist:

		     function():Boolean

		 ]]></param>
<param><![CDATA[getCurrent Retrieves the current value in the sequence: function():TElement

		 ]]></param>
<return><![CDATA[An IEnumerable that contains values of type TElement 

		 ]]></return>
</method>
<method name='empty' fullname='raix.interactive:Enumerable/empty' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an empty sequence

		 ]]></description>
</method>
<method name='fromArray' fullname='raix.interactive:Enumerable/fromArray' isStatic='true' isFinal='false' isOverride='false'  param_names='array' param_types='Array' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an enumerable sequence from an array 

		 ]]></description>
<param><![CDATA[array The array to enumerate

		 ]]></param>
<return><![CDATA[An IEnumerable containing values of the same type as array

		 ]]></return>
</method>
<method name='fromProxy' fullname='raix.interactive:Enumerable/fromProxy' isStatic='true' isFinal='false' isOverride='false'  param_names='proxy' param_types='flash.utils:Proxy' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates a sequence from an enumerable proxy object

		 ]]></description>
<param><![CDATA[proxy A enumerable proxy

		 ]]></param>
<return><![CDATA[A sequence that will enumerate through the values in the proxy

		 ]]></return>
</method>
<method name='generate' fullname='raix.interactive:Enumerable/generate' isStatic='true' isFinal='false' isOverride='false'  param_names='initialState;predicate;iterate;resultMap' param_types='Object;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an enumerable sequence by calling back to functions that mainpulate its state 

		 ]]></description>
<param><![CDATA[initialState The initial state value

		 ]]></param>
<param><![CDATA[predicate A function called once for every value (including initialState), returns true while 

		     the sequence has more values: function(state : TState) : Boolean

		 ]]></param>
<param><![CDATA[iterate A function called once for every value (excluding initialState) and returns the new 

		     value for state: function(state : TState) : TState

		 ]]></param>
<param><![CDATA[resultMap A function that maps the current state to a value: 

		     function(state : TState) : TResult 

		 ]]></param>
<return><![CDATA[An IEnumerable sequence that contains values of type TResult

		 ]]></return>
</method>
<method name='range' fullname='raix.interactive:Enumerable/range' isStatic='true' isFinal='false' isOverride='false'  param_names='start;count' param_types='int;int' param_defaults='undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an enumerable sequence that contains the numbers in a 

		 specified range 

		 ]]></description>
<param><![CDATA[start The start value

		 ]]></param>
<param><![CDATA[count The number of values to enumerate, including start

		 ]]></param>
<return><![CDATA[An IEnumerable of int values in the specified range

		 ]]></return>
</method>
<method name='repeat' fullname='raix.interactive:Enumerable/repeat' isStatic='true' isFinal='false' isOverride='false'  param_names='val;count' param_types='Object;int' param_defaults='undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates an enumerable sequence that repeats a value 

		 ]]></description>
<param><![CDATA[val The value to repeat

		 ]]></param>
<param><![CDATA[count The number of times to repeat. A value of 0 will repeat indefinately

		 ]]></param>
<return><![CDATA[An IEnumerable containing the repeated value

		 ]]></return>
</method>
<method name='value' fullname='raix.interactive:Enumerable/value' isStatic='true' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 Creates a sequence that contains a single value 

		 ]]></description>
<param><![CDATA[value The value to wrap in a sequence

		 ]]></param>
<return><![CDATA[A sequence containing the specified value

		 ]]></return>
</method>
<classRec name='AbsEnumerable' fullname='raix.interactive:AbsEnumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\AbsEnumerable.as' namespace='raix.interactive' access='public' baseclass='flash.utils:Proxy' interfaces='raix.interactive:IEnumerable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An abstract implementation of IEnumerable. This class may be made inaccessible in future revisions.

	 ]]></description>
</classRec>
<method name='AbsEnumerable' fullname='raix.interactive:AbsEnumerable/AbsEnumerable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='aggregate' fullname='raix.interactive:AbsEnumerable/aggregate' isStatic='false' isFinal='false' isOverride='false'  param_names='seed;accumulator;resultSelector' param_types='Object;Function;Function' param_defaults='undefined;undefined;null' result_type='Object'>
</method>
<method name='all' fullname='raix.interactive:AbsEnumerable/all' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='Boolean'>
<description><![CDATA[

		 

		 Determines if the every value in the source sequence matches a predicate 

		 function.

		 

		 Uses immediate execution and stops enumerating when a negative match is found.

		 ]]></description>
<param><![CDATA[predicate (optional) A function in the format: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[true if the sequence is empty or all the values in the sequence match the predicate; 

		         false otherwise

		 ]]></return>
</method>
<method name='any' fullname='raix.interactive:AbsEnumerable/any' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Boolean'>
<description><![CDATA[

		 

		 Determines if the predicate argument function returns true for any 

		 item in the sequence. If no function is supplied, true will be returned 

		 if the sequence contains any values 

		 

		 Uses immediate execution and stops enumerating when a match is found. 

		 ]]></description>
<param><![CDATA[predicate (optional) A function in the format: function(element : TElement) : Boolean 

		 ]]></param>
<return><![CDATA[true if a matching value is found or if predicate is null and the

		              sequence contains any values; false otherwise

		 ]]></return>
</method>
<method name='average' fullname='raix.interactive:AbsEnumerable/average' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='Number'>
<description><![CDATA[

		 

		 Retrieves the average value in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty.

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the numeric value of the element 

		 ]]></param>
<return><![CDATA[The average value of the sequence

		 ]]></return>
</method>
<method name='cancel' fullname='raix.interactive:AbsEnumerable/cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 

		 Cancels the operation

		 ]]></description>
</method>
<method name='concat' fullname='raix.interactive:AbsEnumerable/concat' isStatic='false' isFinal='false' isOverride='false'  param_names='other' param_types='raix.interactive:IEnumerable' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that will seemlessly enumerate a second sequence after 

		 the first sequence completes

		 ]]></description>
<param><![CDATA[second The sequence to enumerate after the first sequence

		 ]]></param>
<return><![CDATA[A new sequence that contains the values from the first and second sequence, in order

		 ]]></return>
</method>
<method name='contains' fullname='raix.interactive:AbsEnumerable/contains' isStatic='false' isFinal='false' isOverride='false'  param_names='value;equalityComparer' param_types='Object;Function' param_defaults='undefined;null' result_type='Boolean'>
<description><![CDATA[

		 

		 Determines if the source sequence contains a specific value, optionally 

		 using an equalityComparer function.

		 

		 Uses immediate execution and stops enumerating when a match is found

		 ]]></description>
<param><![CDATA[value The value to be compared

		 ]]></param>
<param><![CDATA[equalityComparer (optional) A function to compare two 

		        values: function(x : TElement, y : TValue) : Boolean 

		 ]]></param>
<return><![CDATA[true if a match was found; false otherwise

		 ]]></return>
</method>
<method name='count' fullname='raix.interactive:AbsEnumerable/count' isStatic='false' isFinal='false' isOverride='false'  result_type='uint'>
<description><![CDATA[

		 

		 Determines the number of elements in the sequence. Uses immediate execution.

		 ]]></description>
<return><![CDATA[The number of elements in the sequence

		 ]]></return>
</method>
<method name='defaultIfEmpty' fullname='raix.interactive:AbsEnumerable/defaultIfEmpty' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue' param_types='Object' param_defaults='null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that will return the given defaultValue 

		 

		 Uses deferred execution

		 ]]></description>
<param><![CDATA[defaultValue (optional) The default value to use if the sequence is empty. 

		        If not supplied, the value will be converted from null (int = 0, boolean = false, etc)

		 ]]></param>
<return><![CDATA[A new IEnumerable sequence

		 ]]></return>
</method>
<method name='distinct' fullname='raix.interactive:AbsEnumerable/distinct' isStatic='false' isFinal='false' isOverride='false'  param_names='hashSelector' param_types='Function' param_defaults='null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that only contains the unique values in the original sequence.

		 

		 If the sequence contains values that are not natively comparable (String, u/int, Number, Boolean),

		 a hashSelector should be specified to return a value that is. An example of this would be to return 

		 the ID property of an entity.

		 

		 Uses deferred execution

		 ]]></description>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		        function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence that contains the distinct values of the original sequence

		 ]]></return>
</method>
<method name='elementAtOrDefault' fullname='raix.interactive:AbsEnumerable/elementAtOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='index;defaultValue' param_types='int;Object' param_defaults='undefined;null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the element at the given index or a default value if 

		 the sequence does not contain that many elements. 

		 ]]></description>
<param><![CDATA[index The zero-based index of the value to return

		 ]]></param>
<return><![CDATA[The value at index

		 ]]></return>
</method>
<method name='elementAt' fullname='raix.interactive:AbsEnumerable/elementAt' isStatic='false' isFinal='false' isOverride='false'  param_names='index' param_types='int' param_defaults='undefined' result_type='Object'>
<description><![CDATA[

		 

		 Returns the element at the given index or throws an IllegalOperationError if 

		 the sequence does not contain that many elements. 

		 ]]></description>
<param><![CDATA[index The zero-based index of the value to return

		 ]]></param>
<return><![CDATA[The value at index

		 ]]></return>
</method>
<method name='except' fullname='raix.interactive:AbsEnumerable/except' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that contains the values in the source sequence that 

		 do not exist in the supplied sequence

		 

		 ]]></description>
<param><![CDATA[right The right side of the except. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the values contained in the source sequence but 

		         not the "right" sequence 

		 ]]></return>
</method>
<method name='filter' fullname='raix.interactive:AbsEnumerable/filter' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Filters the source sequence based on a predicate function. Uses deferred execution.

		 ]]></description>
<param><![CDATA[predicate A function that determines which elements should appear in the result:

		     function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[A sequence that contains values from the source sequence for which predicate returned true

		 ]]></return>
</method>
<method name='firstOrDefault' fullname='raix.interactive:AbsEnumerable/firstOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the first element in the sequence or returns a default value 

		 if the sequence is empty. If predicate is supplied, the first value to match the 

		 predicate will be returned with the default value being returned if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='first' fullname='raix.interactive:AbsEnumerable/first' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence is empty. If predicate is supplied, the first value to match the 

		 predicate will be returned with an IllegalOperationError being thrown if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first value in the sequence or the first value in the sequence that matches predicate

		 ]]></return>
</method>
<method name='getEnumerator' fullname='raix.interactive:AbsEnumerable/getEnumerator' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.interactive:IEnumerator'>
</method>
<method name='groupBy' fullname='raix.interactive:AbsEnumerable/groupBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyHashSelector' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Groups elements of a sequence using a key selector function

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for a value in the sequence:

		     function(source : TSource) : TKey

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, maps the source element to an element 

		     to place in the grouping: function(source : TSource) : TElement

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) If specified, returns a natively comparable value

		     for a key in the sequence: function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type IGrouping, where each IGrouping is a sequence 

		     of values of type TElement and a key

		 ]]></return>
</method>
<method name='groupJoin' fullname='raix.interactive:AbsEnumerable/groupJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='inner;outerKeySelector;innerKeySelector;resultSelector;keyHashSelector' param_types='raix.interactive:IEnumerable;Function;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Correlates the elements of two sequences based on keys and groups the results

		 

		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 

		 sequence

		 

		 ]]></description>
<param><![CDATA[inner The sequence to join to the first sequence. Can be any value that can be converted 

		     to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[outerKeySelector Retrieves the key from values in the outer (source) sequence:

		     function(element : TOuterElement) : TKey 

		 ]]></param>
<param><![CDATA[innerKeySelector Retrieves the key from values in the inner sequence:

		     function(element : TInnerElement) : TKey

		 ]]></param>
<param><![CDATA[resultSelector Creates a result element from the source sequence and a sequnce of 

		     matching values from the inner sequence:

		     function(outer : TOuterElement, inner : IEnumerable.&lt;TInnerElement&gt;) : TResult

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) Returns a natively comparable value for a key:

		     function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type TResult that are obtained by joining outer and inner

		     sequences.

		 ]]></return>
</method>
<method name='intersect' fullname='raix.interactive:AbsEnumerable/intersect' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that contains only the values contained in both sequences

		 

		 ]]></description>
<param><![CDATA[right The right side of the intersection. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the unique values contained in both sequence 

		 ]]></return>
</method>
<method name='join' fullname='raix.interactive:AbsEnumerable/join' isStatic='false' isFinal='false' isOverride='false'  param_names='inner;outerKeySelector;innerKeySelector;resultSelector;keyHashSelector' param_types='raix.interactive:IEnumerable;Function;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Correlates the elements of two sequences based on keys.

		 

		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 

		 sequence

		 

		 ]]></description>
<param><![CDATA[inner The sequence to join to the first sequence. Can be any value that can be converted 

		     to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[outerKeySelector Retrieves the key from values in the outer (source) sequence:

		     function(element : TOuterElement) : TKey 

		 ]]></param>
<param><![CDATA[innerKeySelector Retrieves the key from values in the inner sequence:

		     function(element : TInnerElement) : TKey

		 ]]></param>
<param><![CDATA[resultSelector Creates a result element from two matching elements:

		     function(outer : TOuterElement, inner : TInnerElement) : TResult

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) Returns a natively comparable value for a key:

		     function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[A sequence that has elements of type TResult that are obtained by joining outer and inner

		     sequences.

		 ]]></return>
</method>
<method name='lastOrDefault' fullname='raix.interactive:AbsEnumerable/lastOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the last element in the sequence or returns a default value 

		 if the sequence is empty. If predicate is supplied, the last value to match the 

		 predicate will be returned with the default value being returned if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The last matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='last' fullname='raix.interactive:AbsEnumerable/last' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the last element in the sequence or throws an IllegalOperationError 

		 if the sequence is empty. If predicate is supplied, the last value to match the 

		 predicate will be returned with an IllegalOperationError being thrown if no 

		 values match the predicate

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The last matching value

		 ]]></return>
</method>
<method name='mapMany' fullname='raix.interactive:AbsEnumerable/mapMany' isStatic='false' isFinal='false' isOverride='false'  param_names='collectionSelector;resultSelector' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Maps a sequence for each value in the source sequence and concatonates the results into 

		 a single sequence. Uses deferred execution.

		 

		 ]]></description>
<param><![CDATA[collectionSelector A function to retrieve the sequence for a value in the source sequence: 

		     function(element : TElement) : IEnumerable.&lt;TCollection>

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that creates a result element from each source element 

		     and each of its enumerated collection values: 

		     function(element : TElement, value : TCollection) : TResult

		 ]]></param>
<return><![CDATA[A sequence that contains values of type TResult if resultSelector is specified, 

		     or TCollection if it is not.

		 ]]></return>
</method>
<method name='map' fullname='raix.interactive:AbsEnumerable/map' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Projects (converts) values using a selector function. Uses deferred execution

		 ]]></description>
<param><![CDATA[selector Projects the values from the source sequence: 

		     function(element : TElement) : TResult

		 ]]></param>
<return><![CDATA[A new sequence that contains the projected values of type TResult

		 ]]></return>
</method>
<method name='max' fullname='raix.interactive:AbsEnumerable/max' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector;comparer' param_types='Function;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 

		 Retrieves the maximum element in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty.

		 

		 If the comparison value (either the original element or the value returned by valueSelector)

		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 

		 to compare the values

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the value to be 

		        compared for each element in the sequence: function(element : TElement) : TValue

		 ]]></param>
<param><![CDATA[comparer (optional) If specified, compares the value (either element 

		        value or the value returned by valueSelector): 

		        function(value : TValue) : int

		 ]]></param>
<return><![CDATA[The sequence element deemed to be the maximum value

		 ]]></return>
</method>
<method name='min' fullname='raix.interactive:AbsEnumerable/min' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector;comparer' param_types='Function;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 

		 Retrieves the minimum element in the sequence. Throws an IllegalOperationError 

		 if the sequence is empty

		 

		 If the comparison value (either the original element or the value returned by valueSelector)

		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 

		 to compare the values

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, determines the value to be 

		        compared for each element in the sequence: function(element : TElement) : TValue

		 ]]></param>
<param><![CDATA[comparer (optional) If specified, compares the value (either element 

		        value or the value returned by valueSelector): 

		        function(value : TValue) : int

		 ]]></param>
<return><![CDATA[The sequence element deemed to be the minimum value

		 ]]></return>
</method>
<method name='nextNameIndex' fullname='raix.interactive:AbsEnumerable/flash_proxy:nextNameIndex' isStatic='false' isFinal='false' isOverride='true'  param_names='index' param_types='int' param_defaults='undefined' result_type='int'>
<description><![CDATA[

		 ]]></description>
<inheritDoc><![CDATA[]]></inheritDoc>
</method>
<method name='nextValue' fullname='raix.interactive:AbsEnumerable/flash_proxy:nextValue' isStatic='false' isFinal='false' isOverride='true'  param_names='index' param_types='int' param_defaults='undefined' result_type='*'>
<description><![CDATA[

		 ]]></description>
<inheritDoc><![CDATA[]]></inheritDoc>
</method>
<method name='ofType' fullname='raix.interactive:AbsEnumerable/ofType' isStatic='false' isFinal='false' isOverride='false'  param_names='cls' param_types='Class' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Filters values from a sequence based on their type

		 ]]></description>
<param><![CDATA[cls A class on which to filter values from the source sequence.

		 ]]></param>
<return><![CDATA[A sequence that contains only elements from the source sequence that are of type 

		     cls (or a subclass)

		 ]]></return>
</method>
<method name='orderByDescending' fullname='raix.interactive:AbsEnumerable/orderByDescending' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 

		 Orders the values in the source sequence in descending order

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
</method>
<method name='orderBy' fullname='raix.interactive:AbsEnumerable/orderBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
<description><![CDATA[

		 

		 Orders the values in the source sequence in ascending order

		 ]]></description>
<param><![CDATA[keySelector A function that retrieves the key used to order the values in the source sequence:

		     function(element : TElement) : TKey

		 ]]></param>
<param><![CDATA[comparer (optional) A function that compares key values. The return value should follow rules of 

		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int

		 ]]></param>
<return><![CDATA[An IOrderedObservable that can be enumerated or further ordered using methods 

		     available on IOrderedObservable

		 ]]></return>
</method>
<method name='reduce' fullname='raix.interactive:AbsEnumerable/reduce' isStatic='false' isFinal='false' isOverride='false'  param_names='seed;accumulator;resultSelector' param_types='Object;Function;Function' param_defaults='undefined;undefined;null' result_type='Object'>
<description><![CDATA[

		 

		 Aggregates values in a sequence using functions passed as arguments.

		 

		 Accumulates a value, starting with seed, by calling accumulator for each value in the source 

		 sequence and using the return value as the new accumulated value. When the sequence completes, 

		 the accumulated value is (optonally) mapped through resultSelector before being returned.

		 ]]></description>
<param><![CDATA[seed The initial value for the accumulation

		 ]]></param>
<param><![CDATA[accumulator A function that returns the new accumulated value: 

		        function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that maps the final accumulate value before being returned

		 ]]></param>
<return><![CDATA[The return value of resultSelector (if supplied) or the final accumulate value if 

		         resultSelector is not supplied

		 ]]></return>
</method>
<method name='repeat' fullname='raix.interactive:AbsEnumerable/repeat' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='0' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Repeats the source sequence a specified number of times 

		 ]]></description>
<param><![CDATA[count (optional) The number of times to repeat the sequence. If 0, the 

		     sequence will be repeated indefinately

		 ]]></param>
<return><![CDATA[A sequence containing values of the same type as the source

		 ]]></return>
</method>
<method name='reset' fullname='raix.interactive:AbsEnumerable/private:reset' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='reverse' fullname='raix.interactive:AbsEnumerable/reverse' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Reverses the values in the source sequence

		 ]]></description>
<return><![CDATA[A new sequence containing the reversed values of the source sequence

		 ]]></return>
</method>
<method name='scan' fullname='raix.interactive:AbsEnumerable/scan' isStatic='false' isFinal='false' isOverride='false'  param_names='seed;accumulator;resultSelector' param_types='Object;Function;Function' param_defaults='undefined;undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a sequence that aggregates values using functions passed as arguments, using 

		 deferred execution and returning the values accumulated values as they are returned.

		 

		 Accumulates a value, starting with seed, by calling accumulator for each value in the 

		 source sequence and using the return value as the new accumulated value. Each time  

		 a new value is accumulated, the accumulated value is (optonally) mapped through 

		 resultSelector before being returned.

		 ]]></description>
<param><![CDATA[seed The initial value for the accumulation

		 ]]></param>
<param><![CDATA[accumulator A function that returns the new accumulated value: 

		        function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[resultSelector (optional) A function that maps the final accumulate value before being returned

		 ]]></param>
<return><![CDATA[A sequence of type TAccumulate that can be enumerated

		 ]]></return>
</method>
<method name='sequenceEqual' fullname='raix.interactive:AbsEnumerable/sequenceEqual' isStatic='false' isFinal='false' isOverride='false'  param_names='right;comparer' param_types='raix.interactive:IEnumerable;Function' param_defaults='undefined;null' result_type='Boolean'>
<description><![CDATA[

		 

		 Determines whether two sequences are equal. Uses immediate execution 

		 

		 ]]></description>
<param><![CDATA[right Ths sequence to compare to the source

		 ]]></param>
<param><![CDATA[comparer A function that will determine equality between left and right values:

		     function(left : TLeft, right : TRight) : Boolean

		 ]]></param>
<return><![CDATA[true if the sequences are of equal length and all of their values are equal

		 ]]></return>
</method>
<method name='singleOrDefault' fullname='raix.interactive:AbsEnumerable/singleOrDefault' isStatic='false' isFinal='false' isOverride='false'  param_names='defaultValue;predicate' param_types='Object;Function' param_defaults='null;null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence does contains multiple values, but returns a default value if 

		 the sequence returns no values. If predicate is supplied, the first value to match 

		 the predicate will be returned with an IllegalOperationError 

		 being thrown if the sequence contains more than one match and a default value being 

		 returned if no matches are found

		 ]]></description>
<param><![CDATA[defaultValue A defaultValue to 

		 ]]></param>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first matching value in the sequence or defaultValue

		 ]]></return>
</method>
<method name='single' fullname='raix.interactive:AbsEnumerable/single' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='Object'>
<description><![CDATA[

		 

		 Returns the first element in the sequence or throws an IllegalOperationError 

		 if the sequence does not contain exactly one value. If predicate is supplied, 

		 the first value to match the predicate will be returned with an IllegalOperationError 

		 being thrown if the sequence does not contain exactly one match

		 ]]></description>
<param><![CDATA[predicate (optional) A predicate used to match values: function(element : TElement) : Boolean

		 ]]></param>
<return><![CDATA[The first value in the sequence or the first value in the sequence that matches predicate

		 ]]></return>
</method>
<method name='skipLast' fullname='raix.interactive:AbsEnumerable/skipLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that excludes the specified number of values from 

		 the end of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to skip from the end of source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='skipWhile' fullname='raix.interactive:AbsEnumerable/skipWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that skips values from the source sequence 

		 until a specified predicate returns false, at which point values will be 

		 returned from the rest of sequence 

		 ]]></description>
<param><![CDATA[predicate A function that determines whether values should still be skipped 

		     from the source sequence: function(element:TElement) : Boolean 

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='skip' fullname='raix.interactive:AbsEnumerable/skip' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that excludes the specified number of values from 

		 the start of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to skip from the source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='sum' fullname='raix.interactive:AbsEnumerable/sum' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='Number'>
<description><![CDATA[

		 

		 Returns the total numeric value of every value in the sequence 

		 ]]></description>
<param><![CDATA[valueSelector (optional) If specified, can be used to specify the numeric 

		        value for each element in the sequence 

		 ]]></param>
<return><![CDATA[The summed values of each element in the sequence

		 ]]></return>
</method>
<method name='takeLast' fullname='raix.interactive:AbsEnumerable/takeLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that includes a maximum number of elements to take from 

		 the end of the first sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to take from the end of source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='takeWhile' fullname='raix.interactive:AbsEnumerable/takeWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that includes values from the source sequence 

		 until a specified predicate returns false, at which point the sequence will end 

		 ]]></description>
<param><![CDATA[predicate A function that determines whether values should still be taken 

		     from the source sequence: function(element:TElement) : Boolean 

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='take' fullname='raix.interactive:AbsEnumerable/take' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that includes a maximum number of elements from the first sequence 

		 ]]></description>
<param><![CDATA[count The number of elements to take from the source sequence

		 ]]></param>
<return><![CDATA[A new sequence containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='toArray' fullname='raix.interactive:AbsEnumerable/toArray' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
<description><![CDATA[

		 

		 Retrieves an array containing all the values in the sequence 

		 ]]></description>
<return><![CDATA[An Array containing values of the same type as the source sequence

		 ]]></return>
</method>
<method name='toDictionary' fullname='raix.interactive:AbsEnumerable/toDictionary' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector' param_types='Function;Function' param_defaults='undefined;null' result_type='flash.utils:Dictionary'>
<description><![CDATA[

		 

		 Converts the sequence to a Dictionary. Uses immediate execution

		 

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for each element in the sequence

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, provides the "values"  

		     in the lookup. If not specified, the original element will be used

		 ]]></param>
<return><![CDATA[A Dictionary

		 ]]></return>
</method>
<method name='toLookup' fullname='raix.interactive:AbsEnumerable/toLookup' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyHashSelector' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.interactive:ILookup'>
<description><![CDATA[

		 

		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 

		 differences:

		 

		 <ul>

		 <li>Supports null keys</li>

		 <li>Returns an empty sequence for requests for keys that do not exist</li>

		 </ul>

		 

		 Uses immediate execution

		 

		 ]]></description>
<param><![CDATA[keySelector Retrieves the key for each element in the sequence

		 ]]></param>
<param><![CDATA[elementSelector (optional) If specified, provides the "values"  

		     in the lookup. If not specified, the original element will be used

		 ]]></param>
<param><![CDATA[keyHashSelector (optional) If the value returned by keySelector is not natively 

		        comparable (ie. String, u/int, Number, Boolean), keyHashSelector can be used to 

		        provide comparable values for the keys: function(key : TKey) : THash

		 ]]></param>
<return><![CDATA[An ILookup

		 ]]></return>
</method>
<method name='toObservable' fullname='raix.interactive:AbsEnumerable/toObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 

		 ]]></description>
<param><![CDATA[scheduler (optional) The scheduler to use to distribute the values. Defaults to 

		     Scheduler.asynchronous

		 ]]></param>
<return><![CDATA[An observable sequence that contains values of the same type as the source sequence

		 ]]></return>
</method>
<method name='union' fullname='raix.interactive:AbsEnumerable/union' isStatic='false' isFinal='false' isOverride='false'  param_names='right;hashSelector' param_types='*;Function' param_defaults='undefined;null' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Returns a new sequence that contains the unique values across two sequences

		 

		 ]]></description>
<param><![CDATA[right The right side of the union. Can be any value that can be converted 

		              to an IEnumerable using toEnumerable

		 ]]></param>
<param><![CDATA[hashSelector (optional) If specified, returns a unique value for the element:

		                     function(element : TElement) : THash

		 ]]></param>
<return><![CDATA[A new sequence containing the distinct values across both sequences 

		 ]]></return>
</method>
<method name='zip' fullname='raix.interactive:AbsEnumerable/zip' isStatic='false' isFinal='false' isOverride='false'  param_names='right;resultSelector' param_types='raix.interactive:IEnumerable;Function' param_defaults='undefined;undefined' result_type='raix.interactive:IEnumerable'>
<description><![CDATA[

		 

		 Pairs values from two sequences in order and uses a selector function to project the results

		 ]]></description>
<param><![CDATA[right The sequence to pair with the left (source) sequence

		 ]]></param>
<param><![CDATA[resultSelector A function to map values from the left and right sequences:

		     function(left : TLeft, right : TRight) : TResult

		 ]]></param>
<return><![CDATA[A sequence containing values of type TResult

		 ]]></return>
</method>
<field name='_currentEnumerator' fullname='raix.interactive:AbsEnumerable/private:_currentEnumerator' type='raix.interactive:IEnumerator' isStatic='false' isConst='false' >
</field>
<field name='_currentIndex' fullname='raix.interactive:AbsEnumerable/private:_currentIndex' type='int' isStatic='false' isConst='false' defaultValue='0' >
</field>
<classRec name='OrderedEnumerable' fullname='raix.interactive:OrderedEnumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\OrderedEnumerable.as' namespace='raix.interactive' access='internal' baseclass='raix.interactive:AbsEnumerable' interfaces='raix.interactive:IOrderedEnumerable' isFinal='false' isDynamic='false' >
</classRec>
<method name='OrderedEnumerable' fullname='raix.interactive:OrderedEnumerable/OrderedEnumerable' isStatic='false' isFinal='false' isOverride='false'  param_names='source;compositeSelector;compositeComparer' param_types='raix.interactive:IEnumerable;Function;Function' param_defaults='undefined;undefined;undefined' result_type='*'>
</method>
<method name='createOrderedEnumerable' fullname='raix.interactive:OrderedEnumerable/createOrderedEnumerable' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer;descending' param_types='Function;Function;Boolean' param_defaults='undefined;undefined;undefined' result_type='raix.interactive:IOrderedEnumerable'>
</method>
<method name='getEnumerator' fullname='raix.interactive:OrderedEnumerable/getEnumerator' isStatic='false' isFinal='false' isOverride='true'  result_type='raix.interactive:IEnumerator'>
</method>
<method name='partition' fullname='raix.interactive:OrderedEnumerable/private:partition' isStatic='false' isFinal='false' isOverride='false'  param_names='indexes;keys;left;right;pivot' param_types='Array;Array;int;int;int' param_defaults='undefined;undefined;undefined;undefined;undefined' result_type='int'>
</method>
<method name='thenByDescending' fullname='raix.interactive:OrderedEnumerable/thenByDescending' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
</method>
<method name='thenBy' fullname='raix.interactive:OrderedEnumerable/thenBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;comparer' param_types='Function;Function' param_defaults='undefined;null' result_type='raix.interactive:IOrderedEnumerable'>
</method>
<field name='_compositeComparer' fullname='raix.interactive:OrderedEnumerable/private:_compositeComparer' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_compositeSelector' fullname='raix.interactive:OrderedEnumerable/private:_compositeSelector' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_source' fullname='raix.interactive:OrderedEnumerable/private:_source' type='raix.interactive:IEnumerable' isStatic='false' isConst='false' >
</field>
<classRec name='Lookup' fullname='raix.interactive:Lookup' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\Lookup.as' namespace='raix.interactive' access='internal' baseclass='raix.interactive:AbsEnumerable' interfaces='raix.interactive:ILookup' isFinal='false' isDynamic='false' >
</classRec>
<method name='Lookup' fullname='raix.interactive:Lookup/Lookup' isStatic='false' isFinal='false' isOverride='false'  param_names='hashSelector' param_types='Function' param_defaults='undefined' result_type='*'>
</method>
<method name='add' fullname='raix.interactive:Lookup/raix.interactive:add' isStatic='false' isFinal='false' isOverride='false'  param_names='key;value' param_types='Object;Object' param_defaults='undefined;undefined' result_type='void'>
</method>
<method name='containsKey' fullname='raix.interactive:Lookup/containsKey' isStatic='false' isFinal='false' isOverride='false'  param_names='key' param_types='Object' param_defaults='undefined' result_type='Boolean'>
</method>
<method name='count' fullname='raix.interactive:Lookup/count' isStatic='false' isFinal='false' isOverride='true'  result_type='uint'>
</method>
<method name='getEnumerator' fullname='raix.interactive:Lookup/getEnumerator' isStatic='false' isFinal='false' isOverride='true'  result_type='raix.interactive:IEnumerator'>
</method>
<method name='getHashedKey' fullname='raix.interactive:Lookup/private:getHashedKey' isStatic='false' isFinal='false' isOverride='false'  param_names='key' param_types='Object' param_defaults='undefined' result_type='Object'>
</method>
<method name='getValues' fullname='raix.interactive:Lookup/getValues' isStatic='false' isFinal='false' isOverride='false'  param_names='key' param_types='Object' param_defaults='undefined' result_type='raix.interactive:IEnumerable'>
</method>
<field name='_count' fullname='raix.interactive:Lookup/private:_count' type='uint' isStatic='false' isConst='false' defaultValue='0' >
</field>
<field name='_hashMap' fullname='raix.interactive:Lookup/private:_hashMap' type='flash.utils:Dictionary' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_hashSelector' fullname='raix.interactive:Lookup/private:_hashSelector' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_keys' fullname='raix.interactive:Lookup/private:_keys' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_nullKey' fullname='raix.interactive:Lookup/private:_nullKey' type='Object' isStatic='true' isConst='false' defaultValue='unknown' >
</field>
<classRec name='Grouping' fullname='raix.interactive:Grouping' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\Grouping.as' namespace='raix.interactive' access='internal' baseclass='raix.interactive:AbsEnumerable' interfaces='raix.interactive:IGrouping' isFinal='false' isDynamic='false' >
</classRec>
<method name='Grouping' fullname='raix.interactive:Grouping/Grouping' isStatic='false' isFinal='false' isOverride='false'  param_names='key;elements' param_types='Object;raix.interactive:IEnumerable' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='getEnumerator' fullname='raix.interactive:Grouping/getEnumerator' isStatic='false' isFinal='false' isOverride='true'  result_type='raix.interactive:IEnumerator'>
</method>
<method name='key' fullname='raix.interactive:Grouping/key/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
</method>
<field name='_elements' fullname='raix.interactive:Grouping/private:_elements' type='raix.interactive:IEnumerable' isStatic='false' isConst='false' >
</field>
<field name='_key' fullname='raix.interactive:Grouping/private:_key' type='Object' isStatic='false' isConst='false' >
</field>
<classRec name='ClosureEnumerable' fullname='raix.interactive:ClosureEnumerable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\interactive\ClosureEnumerable.as' namespace='raix.interactive' access='internal' baseclass='raix.interactive:AbsEnumerable' isFinal='false' isDynamic='false' >
</classRec>
<method name='ClosureEnumerable' fullname='raix.interactive:ClosureEnumerable/ClosureEnumerable' isStatic='false' isFinal='false' isOverride='false'  param_names='createEnumerator' param_types='Function' param_defaults='undefined' result_type='*'>
</method>
<method name='getEnumerator' fullname='raix.interactive:ClosureEnumerable/getEnumerator' isStatic='false' isFinal='false' isOverride='true'  result_type='raix.interactive:IEnumerator'>
</method>
<field name='_createEnumerator' fullname='raix.interactive:ClosureEnumerable/private:_createEnumerator' type='Function' isStatic='false' isConst='false' >
</field>
<classRec name='Unit' fullname='raix.reactive:Unit' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Unit.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a valueClass that can be used when 

	 an observable sequence logically has no valueClass

	 ]]></description>
</classRec>
<method name='Unit' fullname='raix.reactive:Unit/Unit' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<interfaceRec name='ICancelable' fullname='raix.reactive:ICancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\ICancelable.as' namespace='raix.reactive' access='public' baseClasses='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a handle that can be used to cancel an operation 

	 

	 ]]></description>
<see><![CDATA[raix.reactive.CompositeCancelable, raix.reactive.BooleanCancelable, raix.reactive.FutureCancelable, raix.reactive.Cancelable

	]]></see>
</interfaceRec>
<method name='cancel' fullname='raix.reactive:ICancelable/raix.reactive:ICancelable:cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 Cancels the operation

		 ]]></description>
</method>
<classRec name='Plan' fullname='raix.reactive:Plan' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Plan.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A combination of IObservable sequences and a selector that will 

	 map the values of those sequences to an output value. A plan is intended 

	 to be used with Observable.when

	 

	 <p>Generally, a Plan will be created using Pattern.then(), rather 

	 than creating a Plan directly</p>

	 ]]></description>
</classRec>
<method name='Plan' fullname='raix.reactive:Plan/Plan' isStatic='false' isFinal='false' isOverride='false'  param_names='sources;selector' param_types='Array;Function' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='selector' fullname='raix.reactive:Plan/selector/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Function'>
<description><![CDATA[

		 Gets the function selector that will accept one argument for each 

		 sequence in sources and return the output value

		 ]]></description>
</method>
<method name='sources' fullname='raix.reactive:Plan/sources/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
<description><![CDATA[

		 Gets the observable sequences in this plan

		 ]]></description>
</method>
<field name='_selector' fullname='raix.reactive:Plan/private:_selector' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_sources' fullname='raix.reactive:Plan/private:_sources' type='Array' isStatic='false' isConst='false' >
</field>
<interfaceRec name='IObserver' fullname='raix.reactive:IObserver' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\IObserver.as' namespace='raix.reactive' access='public' baseClasses='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An object that receives messages from an IObservable sequence

	 

	 ]]></description>
<see><![CDATA[Observer

	 ]]></see>
</interfaceRec>
<method name='onCompleted' fullname='raix.reactive:IObserver/raix.reactive:IObserver:onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 Notifies the subscriber that the sequence has completed and 

		 that no more messages will be received

		 ]]></description>
</method>
<method name='onError' fullname='raix.reactive:IObserver/raix.reactive:IObserver:onError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Notifies the subscriber that the sequence has halted with an error 

		 and that no more messages will be received

		 ]]></description>
</method>
<method name='onNext' fullname='raix.reactive:IObserver/raix.reactive:IObserver:onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Notifies the subscriber that a value has been received

		 ]]></description>
</method>
<classRec name='TimeStamped' fullname='raix.reactive:TimeStamped' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\TimeStamped.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A wrapper that adds a timestamp to a value

	 ]]></description>
</classRec>
<method name='TimeStamped' fullname='raix.reactive:TimeStamped/TimeStamped' isStatic='false' isFinal='false' isOverride='false'  param_names='value;time' param_types='Object;Number' param_defaults='undefined;undefined' result_type='*'>
<description><![CDATA[

		 Creates a TimeStamped wrapper 

		 ]]></description>
<param><![CDATA[value The value from the original sequence

		 ]]></param>
<param><![CDATA[time The timestamp value

		 ]]></param>
</method>
<method name='timestamp' fullname='raix.reactive:TimeStamped/timestamp/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Number'>
<description><![CDATA[

		 Gets the timestamp value 

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:TimeStamped/value/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Gets the original value 

		 ]]></description>
</method>
<field name='_time' fullname='raix.reactive:TimeStamped/private:_time' type='Number' isStatic='false' isConst='false' >
</field>
<field name='_value' fullname='raix.reactive:TimeStamped/private:_value' type='Object' isStatic='false' isConst='false' >
</field>
<classRec name='TimeInterval' fullname='raix.reactive:TimeInterval' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\TimeInterval.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A wrapper that adds the time interval, in milliseconds,

	 since the last values 

	 ]]></description>
</classRec>
<method name='TimeInterval' fullname='raix.reactive:TimeInterval/TimeInterval' isStatic='false' isFinal='false' isOverride='false'  param_names='value;interval' param_types='Object;Number' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='interval' fullname='raix.reactive:TimeInterval/interval/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Number'>
<description><![CDATA[

		 Gets the internal, in milliseconds, 

		 since the last value

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:TimeInterval/value/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Gets the original value

		 ]]></description>
</method>
<field name='_interval' fullname='raix.reactive:TimeInterval/private:_interval' type='Number' isStatic='false' isConst='false' >
</field>
<field name='_value' fullname='raix.reactive:TimeInterval/private:_value' type='Object' isStatic='false' isConst='false' >
</field>
<classRec name='NotificationKind' fullname='raix.reactive:NotificationKind' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\NotificationKind.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Enumeration for the different types of Notification

	 ]]></description>
</classRec>
<field name='ON_COMPLETED' fullname='raix.reactive:NotificationKind/ON_COMPLETED' type='int' isStatic='true' isConst='true' defaultValue='2' >
<description><![CDATA[

		 An onCompleted message

		 

		 ]]></description>
<see><![CDATA[rx.OnCompleted

		 ]]></see>
</field>
<field name='ON_ERROR' fullname='raix.reactive:NotificationKind/ON_ERROR' type='int' isStatic='true' isConst='true' defaultValue='1' >
<description><![CDATA[

		 An onError message

		 

		 ]]></description>
<see><![CDATA[rx.OnError

		 ]]></see>
</field>
<field name='ON_NEXT' fullname='raix.reactive:NotificationKind/ON_NEXT' type='int' isStatic='true' isConst='true' defaultValue='0' >
<description><![CDATA[

		 An onNext (value) message

		 

		 ]]></description>
<see><![CDATA[rx.OnNext

		 ]]></see>
</field>
<classRec name='CompositeCancelable' fullname='raix.reactive:CompositeCancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\CompositeCancelable.as' namespace='raix.reactive' access='public' baseclass='Object' interfaces='raix.reactive:ICancelable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a cancelable resource that controls multiple 

	 other cancelable resources 

	 ]]></description>
</classRec>
<method name='CompositeCancelable' fullname='raix.reactive:CompositeCancelable/CompositeCancelable' isStatic='false' isFinal='false' isOverride='false'  param_names='values' param_types='Array' param_defaults='null' result_type='*'>
<description><![CDATA[

		 Creates a composite cancelable instance with the cancelable 

		 instances to start with

		 ]]></description>
</method>
<method name='add' fullname='raix.reactive:CompositeCancelable/add' isStatic='false' isFinal='false' isOverride='false'  param_names='cancelable' param_types='raix.reactive:ICancelable' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Adds a cancelable resource to the list of cancelable resources. If 

		 this instance has already been canceled, the resource will be immediately 

		 canceled and not added to the list.

		 ]]></description>
</method>
<method name='cancel' fullname='raix.reactive:CompositeCancelable/cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 Cancels (and removes) all resources in this instance

		 ]]></description>
</method>
<method name='remove' fullname='raix.reactive:CompositeCancelable/remove' isStatic='false' isFinal='false' isOverride='false'  param_names='cancelable' param_types='raix.reactive:ICancelable' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Removes a cancelable resource from the list

		 ]]></description>
</method>
<method name='cancelables' fullname='raix.reactive:CompositeCancelable/cancelables/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
<description><![CDATA[

		 Gets the list of cancelable resources in this instance

		 ]]></description>
</method>
<method name='count' fullname='raix.reactive:CompositeCancelable/count/get' isStatic='false' isFinal='false' isOverride='false'  result_type='uint'>
<description><![CDATA[

		 Gets the number of resources in this list

		 ]]></description>
</method>
<field name='_cancelables' fullname='raix.reactive:CompositeCancelable/private:_cancelables' type='Array' isStatic='false' isConst='false' >
</field>
<field name='_cancelled' fullname='raix.reactive:CompositeCancelable/private:_cancelled' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<classRec name='ClosureCancelable' fullname='raix.reactive:ClosureCancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\ClosureCancelable.as' namespace='raix.reactive' access='internal' baseclass='Object' interfaces='raix.reactive:ICancelable' isFinal='false' isDynamic='false' >
</classRec>
<method name='ClosureCancelable' fullname='raix.reactive:ClosureCancelable/ClosureCancelable' isStatic='false' isFinal='false' isOverride='false'  param_names='unsubscribeFunc' param_types='Function' param_defaults='undefined' result_type='*'>
</method>
<method name='cancel' fullname='raix.reactive:ClosureCancelable/cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='empty' fullname='raix.reactive:ClosureCancelable/empty' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive:ClosureCancelable'>
</method>
<field name='_isUnsubscribed' fullname='raix.reactive:ClosureCancelable/private:_isUnsubscribed' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_unsubscribeFunc' fullname='raix.reactive:ClosureCancelable/private:_unsubscribeFunc' type='Function' isStatic='false' isConst='false' >
</field>
<classRec name='BooleanCancelable' fullname='raix.reactive:BooleanCancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\BooleanCancelable.as' namespace='raix.reactive' access='public' baseclass='Object' interfaces='raix.reactive:ICancelable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a cancelable operation, the canceled status of which can 

	 be checked by isCanceled 

	]]></description>
</classRec>
<method name='BooleanCancelable' fullname='raix.reactive:BooleanCancelable/BooleanCancelable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='cancel' fullname='raix.reactive:BooleanCancelable/cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 Cancels the operation. isCanceled will return true after this call.

		 ]]></description>
</method>
<method name='isCanceled' fullname='raix.reactive:BooleanCancelable/isCanceled/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
<description><![CDATA[

		 Determines if canceled() has been called on this instance

		 ]]></description>
</method>
<field name='_isCanceled' fullname='raix.reactive:BooleanCancelable/private:_isCanceled' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<classRec name='TimeoutError' fullname='raix.reactive:TimeoutError' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\TimeoutError.as' namespace='raix.reactive' access='public' baseclass='Error' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An error thrown by Observable.timeout by default

	 ]]></description>
</classRec>
<method name='TimeoutError' fullname='raix.reactive:TimeoutError/TimeoutError' isStatic='false' isFinal='false' isOverride='false'  param_names='message;id' param_types='String;int' param_defaults='undefined;0' result_type='*'>
</method>
<classRec name='ClosureObserver' fullname='raix.reactive:ClosureObserver' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\ClosureObserver.as' namespace='raix.reactive' access='internal' baseclass='Object' interfaces='raix.reactive:IObserver' isFinal='false' isDynamic='false' >
</classRec>
<method name='ClosureObserver' fullname='raix.reactive:ClosureObserver/ClosureObserver' isStatic='false' isFinal='false' isOverride='false'  param_names='onNext;onComplete;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='*'>
</method>
<method name='onCompleted' fullname='raix.reactive:ClosureObserver/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='onError' fullname='raix.reactive:ClosureObserver/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='void'>
</method>
<method name='onNext' fullname='raix.reactive:ClosureObserver/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
</method>
<field name='_onComplete' fullname='raix.reactive:ClosureObserver/private:_onComplete' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_onError' fullname='raix.reactive:ClosureObserver/private:_onError' type='Function' isStatic='false' isConst='false' >
</field>
<field name='_onNext' fullname='raix.reactive:ClosureObserver/private:_onNext' type='Function' isStatic='false' isConst='false' >
</field>
<classRec name='Pattern' fullname='raix.reactive:Pattern' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Pattern.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A combination of multiple IObservable sequences that can be combined 

	 into a Plan

	 

	 <p>Generally, a Pattern will be created using IObservable.and or 

	 Pattern.and(), rather than creating a Pattern directly</p>

	 ]]></description>
</classRec>
<method name='Pattern' fullname='raix.reactive:Pattern/Pattern' isStatic='false' isFinal='false' isOverride='false'  param_names='sources' param_types='Array' param_defaults='undefined' result_type='*'>
</method>
<method name='and' fullname='raix.reactive:Pattern/and' isStatic='false' isFinal='false' isOverride='false'  param_names='source' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:Pattern'>
<description><![CDATA[

		 Creates another pattern that combines the IObservable sequences 

		 of this Pattern with another IObservable sequence 

		 ]]></description>
<param><![CDATA[source The IObservable sequence to add

		 ]]></param>
<return><![CDATA[A Pattern with the new set of sequences

		 

		 ]]></return>
</method>
<method name='then' fullname='raix.reactive:Pattern/then' isStatic='false' isFinal='false' isOverride='false'  param_names='thenFunction' param_types='Function' param_defaults='undefined' result_type='raix.reactive:Plan'>
<description><![CDATA[

		 Creates a Plan from this Pattern, by supplying a 

		 valueClass and a mappingFunction for the values from each 

		 sequence in this Pattern 

		 ]]></description>
<param><![CDATA[valueClass The valueClass that will be returned by thenFunction

		 ]]></param>
<param><![CDATA[thenFunction The function that will accept one argument for each 

		 sequence in the pattern and output a valueClass

		 ]]></param>
<return><![CDATA[A Plan that can be used with Observable.when

		 ]]></return>
</method>
<field name='_sources' fullname='raix.reactive:Pattern/private:_sources' type='Array' isStatic='false' isConst='false' >
</field>
<classRec name='SafetyObserver' fullname='raix.reactive:SafetyObserver' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\SafetyObserver.as' namespace='raix.reactive' access='internal' baseclass='Object' interfaces='raix.reactive:IObserver' isFinal='false' isDynamic='false' >
</classRec>
<method name='SafetyObserver' fullname='raix.reactive:SafetyObserver/SafetyObserver' isStatic='false' isFinal='false' isOverride='false'  param_names='innerObserver' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='*'>
</method>
<method name='onCompleted' fullname='raix.reactive:SafetyObserver/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='onError' fullname='raix.reactive:SafetyObserver/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='void'>
</method>
<method name='onNext' fullname='raix.reactive:SafetyObserver/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
</method>
<method name='setInactive' fullname='raix.reactive:SafetyObserver/private:setInactive' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='setSubscription' fullname='raix.reactive:SafetyObserver/setSubscription' isStatic='false' isFinal='false' isOverride='false'  param_names='subscription' param_types='raix.reactive:ICancelable' param_defaults='undefined' result_type='void'>
</method>
<field name='_active' fullname='raix.reactive:SafetyObserver/private:_active' type='Boolean' isStatic='false' isConst='false' >
</field>
<field name='_innerObserver' fullname='raix.reactive:SafetyObserver/private:_innerObserver' type='raix.reactive:IObserver' isStatic='false' isConst='false' >
</field>
<field name='_subscription' fullname='raix.reactive:SafetyObserver/private:_subscription' type='raix.reactive:ICancelable' isStatic='false' isConst='false' >
</field>
<classRec name='MutableCancelable' fullname='raix.reactive:MutableCancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\MutableCancelable.as' namespace='raix.reactive' access='public' baseclass='Object' interfaces='raix.reactive:ICancelable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	A cancelable resource than is not immediately available

	]]></description>
</classRec>
<method name='MutableCancelable' fullname='raix.reactive:MutableCancelable/MutableCancelable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='cancel' fullname='raix.reactive:MutableCancelable/cancel' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 Cancels the operation for current and future innerCancelable values

		 ]]></description>
</method>
<method name='cancelable' fullname='raix.reactive:MutableCancelable/cancelable/set' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='raix.reactive:ICancelable' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Assigns the cancelable operation.

		 

		 If an existing value exists for innerCancelable, it will be canceled.

		 

		 If cancel() has already been called on this FutureCancelable, the value 

		 will be instantly canceled and innerCancelable will be null

		 ]]></description>
</method>
<field name='_cancelable' fullname='raix.reactive:MutableCancelable/private:_cancelable' type='raix.reactive:ICancelable' isStatic='false' isConst='false' defaultValue='null' >
</field>
<field name='_canceled' fullname='raix.reactive:MutableCancelable/private:_canceled' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<classRec name='Notification' fullname='raix.reactive:Notification' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Notification.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents one of the three messages that can be sent to 

	 an observer.

	 

	 ]]></description>
<see><![CDATA[rx.OnNext 

	 ]]></see>
<see><![CDATA[rx.OnCompleted 

	 ]]></see>
<see><![CDATA[rx.OnError

	 ]]></see>
</classRec>
<method name='Notification' fullname='raix.reactive:Notification/Notification' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='acceptWith' fullname='raix.reactive:Notification/acceptWith' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Calls the appropriate method on an observer

		 ]]></description>
</method>
<method name='accept' fullname='raix.reactive:Notification/accept' isStatic='false' isFinal='false' isOverride='false'  param_names='onNext;onCompleted;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='void'>
<description><![CDATA[

		 Calls the appropriate method

		 ]]></description>
</method>
<method name='error' fullname='raix.reactive:Notification/error/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Error'>
<description><![CDATA[

		 Gets the error associated with this message or null if there is no error.

		 ]]></description>
</method>
<method name='hasValue' fullname='raix.reactive:Notification/hasValue/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
<description><![CDATA[

		 Determined whether this instance has a value property available

		 ]]></description>
</method>
<method name='kind' fullname='raix.reactive:Notification/kind/get' isStatic='false' isFinal='false' isOverride='false'  result_type='int'>
<description><![CDATA[

		 Gets the NotificationKind of this instance

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:Notification/value/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Gets the value associated with this message

		 ]]></description>
</method>
<interfaceRec name='IObservable' fullname='raix.reactive:IObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\IObservable.as' namespace='raix.reactive' access='public' baseClasses='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An observable (or "push"), sequence of values that often represent data or events that have not yet occured. 

	 Sequences can be manipulated, often combining them with other sequences, and then subscribed to 

	 to receive the output.

	 

	 Chains of sequences are automatically torn down when the sequence completes, errors or is unsubscribed from.

	 ]]></description>
</interfaceRec>
<method name='aggregate' fullname='raix.reactive:IObservable/raix.reactive:IObservable:aggregate' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<metadata>
	<Deprecated owner='raix.reactive:IObservable/raix.reactive:IObservable:aggregate' replacement='reduce' >
	</Deprecated>
</metadata>
</method>
<method name='all' fullname='raix.reactive:IObservable/raix.reactive:IObservable:all' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Determines if all values in the source sequence satisfy a condition

		 ]]></description>
<param><![CDATA[predicate The predicate that determines if a value in the sequence is valid. 

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='and' fullname='raix.reactive:IObservable/raix.reactive:IObservable:and' isStatic='false' isFinal='false' isOverride='false'  param_names='right' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:Pattern'>
<description><![CDATA[ 

		 Creates a pattern by combining the current source with right.

		 

		 ]]></description>
<param><![CDATA[right The other sequence to combine with the pattern.

		 ]]></param>
<return><![CDATA[A pattern representing both sequences

		 ]]></return>
</method>
<method name='any' fullname='raix.reactive:IObservable/raix.reactive:IObservable:any' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Determines if the source sequence contains a value that satisfies a condition

		  

		 ]]></description>
<param><![CDATA[predicate (optional) The predicate that determines if a value in the sequence is valid. 

		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='asObservable' fullname='raix.reactive:IObservable/raix.reactive:IObservable:asObservable' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='average' fullname='raix.reactive:IObservable/raix.reactive:IObservable:average' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Returns the average value of all the elements in the source sequence

		 ]]></description>
<param><![CDATA[valueSelector (optional) The selector function that returns a numeric value from the source value  

		 ]]></param>
<return><![CDATA[An observable sequence of TSource values

		 ]]></return>
</method>
<method name='bufferWithCount' fullname='raix.reactive:IObservable/raix.reactive:IObservable:bufferWithCount' isStatic='false' isFinal='false' isOverride='false'  param_names='count;skip' param_types='uint;uint' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[count The number of values to buffer

		 ]]></param>
<param><![CDATA[skip The number of values to offset after the buffer is emitted.

		 ]]></param>
<return><![CDATA[An observable sequence of arrays of the the same type as the current sequence

		 ]]></return>
</method>
<method name='bufferWithTimeOrCount' fullname='raix.reactive:IObservable/raix.reactive:IObservable:bufferWithTimeOrCount' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;count;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 

		 of values, whichever occurs first

		 ]]></description>
<param><![CDATA[timeMs The maximum amount of time to buffer values for

		 ]]></param>
<param><![CDATA[count The maximum amount of values to include in a single buffer

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='bufferWithTime' fullname='raix.reactive:IObservable/raix.reactive:IObservable:bufferWithTime' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;timeShiftMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[timeMs The amount of time to buffer before the values are released

		 ]]></param>
<param><![CDATA[timeShiftMs The amount of time to offset after the buffer is emitted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of Arrays of the same type as the current sequence

		 ]]></return>
</method>
<method name='cast' fullname='raix.reactive:IObservable/raix.reactive:IObservable:cast' isStatic='false' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Forces values from a source sequence to be of a specific class

		 ]]></description>
<param><![CDATA[valueClass The valueClass of the output sequence

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass 

		 ]]></return>
</method>
<method name='catchErrorDefer' fullname='raix.reactive:IObservable/raix.reactive:IObservable:catchErrorDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='errorClass;deferFunc' param_types='Class;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Runs a specific sequence, determined at runtime, when an error occurs

		 ]]></description>
<param><![CDATA[errorClass The class (and superclass) of error to act on

		 ]]></param>
<param><![CDATA[deferFunc The function to execute in the event of an error. 

		 Signature is <code>function(e : Error) : IObservable</code>

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='catchError' fullname='raix.reactive:IObservable/raix.reactive:IObservable:catchError' isStatic='false' isFinal='false' isOverride='false'  param_names='second' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Runs a specific sequence when an error occurs

		 ]]></description>
<param><![CDATA[second The sequence to subscribe to when an error occurs

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='chain' fullname='raix.reactive:IObservable/raix.reactive:IObservable:chain' isStatic='false' isFinal='false' isOverride='false'  param_names='functions' param_types='Array' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Chains together sequences, starting with the current sequence, using selector functions that 

		 return a sequence for values of the previous.

		 ]]></description>
<param><![CDATA[functions An array of functions that accept a value from the previous sequence and 

		        return a new sequence:

		        function (value : T) : IObservable

		 ]]></param>
<return><![CDATA[An observable sequence of the values returned by the sequence returned by the last 

		 selector in the chain

		 ]]></return>
</method>
<method name='combineLatest' fullname='raix.reactive:IObservable/raix.reactive:IObservable:combineLatest' isStatic='false' isFinal='false' isOverride='false'  param_names='right;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Merges two sequences through a mapping function, using the latest value from either source 

		 ]]></description>
<param><![CDATA[right The sequence to combine with

		 ]]></param>
<param><![CDATA[selector The function that combines values from the two sources. Signature is <code>function(left : this.valueClass, right : right.valueClass) : returnType</code>

		 ]]></param>
<return><![CDATA[An observable sequence of returnType 

		 ]]></return>
</method>
<method name='concatMany' fullname='raix.reactive:IObservable/raix.reactive:IObservable:concatMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Evaluates a new sequence for each value using a selector function and waits for the returned 

		 sequence to complete before resolving the next sequence 

		 ]]></description>
<param><![CDATA[selector Accept a value of the source and returns the IObservable sequence to concatonate:

		     function(value:T) : IObservable

		 ]]></param>
<return><![CDATA[An IObservable sequence containing the values returned

		 ]]></return>
</method>
<method name='concat' fullname='raix.reactive:IObservable/raix.reactive:IObservable:concat' isStatic='false' isFinal='false' isOverride='false'  param_names='source' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Concatonates multiple sequences by running each sequence as the previous one finishes

		 ]]></description>
<param><![CDATA[sources The sequences to concatonate after the current sequence 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='contains' fullname='raix.reactive:IObservable/raix.reactive:IObservable:contains' isStatic='false' isFinal='false' isOverride='false'  param_names='value;comparer' param_types='Object;Function' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Determines if the source sequence contains a specific value 

		 ]]></description>
<param><![CDATA[value The value to check against the sequence

		 ]]></param>
<param><![CDATA[comparer The function used to compare values. Default equality will be used if comparer is null.

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='count' fullname='raix.reactive:IObservable/raix.reactive:IObservable:count' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Returns the number of elements in the source sequence 

		 ]]></description>
<return><![CDATA[An observable sequence of int

		 ]]></return>
</method>
<method name='delay' fullname='raix.reactive:IObservable/raix.reactive:IObservable:delay' isStatic='false' isFinal='false' isOverride='false'  param_names='delayMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Delays all values in a sequences by a specified time 

		 ]]></description>
<param><![CDATA[delayMs The amount of time, in milliseconds, to delay

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to delay the values

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='dematerialize' fullname='raix.reactive:IObservable/raix.reactive:IObservable:dematerialize' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Converts materialized values back into messages  

		 ]]></description>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='distinctUntilChanged' fullname='raix.reactive:IObservable/raix.reactive:IObservable:distinctUntilChanged' isStatic='false' isFinal='false' isOverride='false'  param_names='comparer' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Filters out consecutive duplicates from a source sequence  

		 ]]></description>
<param><![CDATA[comparer (optional) The function used to compare values. Default equality will be used if comparer is null.

		 function(x:TValue, y:TValue) : Boolean

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='expand' fullname='raix.reactive:IObservable/raix.reactive:IObservable:expand' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Recursively expands the values in the sequence using a selector function 

		 ]]></description>
<param><![CDATA[selector Accepts values and returns an expanded sequence for them:

		     function (value : T) : IObservable

		 ]]></param>
<return><![CDATA[An observable sequence of all values emitted by any of the sequences

		 ]]></return>
</method>
<method name='filter' fullname='raix.reactive:IObservable/raix.reactive:IObservable:filter' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Filters out values from a source sequence 

		 ]]></description>
<param><![CDATA[predicate The predicate function to execute for each value to determine if it will be include in the output

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='finallyAction' fullname='raix.reactive:IObservable/raix.reactive:IObservable:finallyAction' isStatic='false' isFinal='false' isOverride='false'  param_names='finallyAction' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Executes a function when the sequence completes, errors or is unsubscribed from

		 ]]></description>
<param><![CDATA[finallyAction The function to execute in the event the sequence completes or errors

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='firstOrDefault' fullname='raix.reactive:IObservable/raix.reactive:IObservable:firstOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the first value in the sequence, or a default value if the sequence completes with no values

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='first' fullname='raix.reactive:IObservable/raix.reactive:IObservable:first' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the first value in the sequence, or an error if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='forkJoin' fullname='raix.reactive:IObservable/raix.reactive:IObservable:forkJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='right;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Combines the current sequence with another, emitting the last values of both after both have completed 

		 ]]></description>
<param><![CDATA[right The sequence to subscribe to, along with the current sequence

		 ]]></param>
<param><![CDATA[selector The function that accepts the last values of both sequences and returns the output value:

		     function(left : TLeft, right : TRight) : TResult 

		 ]]></param>
<return><![CDATA[An observable sequence of TResult

		 ]]></return>
</method>
<method name='groupByUntil' fullname='raix.reactive:IObservable/raix.reactive:IObservable:groupByUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;durationSelector;elementSelector;keyComparer' param_types='Function;Function;Function;Function' param_defaults='undefined;undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Groups values by a key and also provides a lifetime for a grouping

		 ]]></description>
<param><![CDATA[keySelector A selector that maps the key from a source value:

		     function(value:TValue):TKey

		 ]]></param>
<param><![CDATA[durationSelector A selector that returns an observable sequence that will signal 

		     the end of the life of a group by emitting a value or completing:

		     function(group:IGroupedObservable) : IObservable

		 ]]></param>
<param><![CDATA[elementSelector (optional) A selector that maps the source value to the element value that 

		     will be added to the grouped items: function(value:TValue):TElement

		 ]]></param>
<param><![CDATA[keyComparer A equality comparer that compares two keys

		 ]]></param>
<return><![CDATA[An observable sequence of IGroupedObservable

		 ]]></return>
<see><![CDATA[raix.reactive.IGroupedObservable

		 ]]></see>
</method>
<method name='groupBy' fullname='raix.reactive:IObservable/raix.reactive:IObservable:groupBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyComparer' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Groups values by a key

		 ]]></description>
<param><![CDATA[keySelector A selector that maps the key from a source value:

		     function(value:TValue):TKey

		 ]]></param>
<param><![CDATA[elementSelector (optional) A selector that maps the source value to the element value that 

		     will be added to the grouped items: function(value:TValue):TElement

		 ]]></param>
<param><![CDATA[keyComparer A equality comparer that compares two keys

		 ]]></param>
<return><![CDATA[An observable sequence of IGroupedObservable

		 ]]></return>
<see><![CDATA[raix.reactive.IGroupedObservable

		 ]]></see>
</method>
<method name='groupJoin' fullname='raix.reactive:IObservable/raix.reactive:IObservable:groupJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='right;leftWindowSelector;rightWindowSelector;joinSelector' param_types='raix.reactive:IObservable;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 

		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value

		 to a selector to be combined. The output of this selector is emitted to the output stream  

		 ]]></description>
<param><![CDATA[right The right hand side of the join

		 ]]></param>
<param><![CDATA[leftWindowSelector A function that will be called for each value from the left ("this") and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(left:TLeft):IObservable

		 ]]></param>
<param><![CDATA[rightWindowSelector A function that will be called for each value from right and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(right:TRight):IObservable

		 ]]></param>
<param><![CDATA[joinSelector A function that will accept "live" left/right value combinations and return a new value. 

		     The output of this function will be received by any subscribers:

		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult

		 ]]></param>
<return><![CDATA[An observable sequence of TResult values

		 ]]></return>
</method>
<method name='ignoreValues' fullname='raix.reactive:IObservable/raix.reactive:IObservable:ignoreValues' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 

		 ]]></description>
<return><![CDATA[An observable sequence

		 ]]></return>
</method>
<method name='join' fullname='raix.reactive:IObservable/raix.reactive:IObservable:join' isStatic='false' isFinal='false' isOverride='false'  param_names='right;leftWindowSelector;rightWindowSelector;joinSelector' param_types='raix.reactive:IObservable;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 

		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 

		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  

		 ]]></description>
<param><![CDATA[right The right hand side of the join

		 ]]></param>
<param><![CDATA[leftWindowSelector A function that will be called for each value from the left ("this") and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(left:TLeft):IObservable

		 ]]></param>
<param><![CDATA[rightWindowSelector A function that will be called for each value from right and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(right:TRight):IObservable

		 ]]></param>
<param><![CDATA[joinSelector A function that will accept "live" left/right value combinations and return a new value. 

		     The output of this function will be received by any subscribers:

		     function(left : TLeft, right : TRight) : TResult

		 ]]></param>
<return><![CDATA[An observable sequence of TResult (returned by joinSelector)

		 ]]></return>
</method>
<method name='lastOrDefault' fullname='raix.reactive:IObservable/raix.reactive:IObservable:lastOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the last value in the sequence, or the default value if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='last' fullname='raix.reactive:IObservable/raix.reactive:IObservable:last' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the last value in the sequence, or an error if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='let' fullname='raix.reactive:IObservable/raix.reactive:IObservable:let' isStatic='false' isFinal='false' isOverride='false'  param_names='func' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 

		 ]]></description>
<param><![CDATA[func The function to send the current sequence through, and return a new sequence 

		 ]]></param>
<return><![CDATA[The observable sequence returned by func 

		 ]]></return>
</method>
<method name='log' fullname='raix.reactive:IObservable/raix.reactive:IObservable:log' isStatic='false' isFinal='false' isOverride='false'  param_names='message' param_types='String' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Writes sequence activity out to the trace log with a message describing the sequence 

		 ]]></description>
<param><![CDATA[message 

		 ]]></param>
</method>
<method name='mapMany' fullname='raix.reactive:IObservable/raix.reactive:IObservable:mapMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values

		 ]]></description>
<param><![CDATA[valueClass The valueClass of the sequences returned by selector

		 ]]></param>
<param><![CDATA[selector The function that maps values to new observable sequences that will 

		 be merged in the result set: function(value:TValue):IObservable

		 ]]></param>
<return><![CDATA[An observable sequence containing the values emitted from the child observable sequences

		 ]]></return>
</method>
<method name='map' fullname='raix.reactive:IObservable/raix.reactive:IObservable:map' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Maps the values from a source sequence through a function to change their value  

		 ]]></description>
<param><![CDATA[selector The function to be executed with each value

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass result

		 ]]></return>
</method>
<method name='materialize' fullname='raix.reactive:IObservable/raix.reactive:IObservable:materialize' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Converts all messages (next, complete, error) into values 

		 ]]></description>
<return><![CDATA[An observable sequence of rx.Notification

		 ]]></return>
</method>
<method name='mergeMany' fullname='raix.reactive:IObservable/raix.reactive:IObservable:mergeMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;concurrent' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Evaluates a new sequence for each value using a selector function and merges the results 

		 of the sequence returned by the returned sequence, optionally constraining the number of 

		 concurrent sequencing.

		 ]]></description>
<param><![CDATA[selector Accept a value of the source and returns the IObservable sequence to merge:

		     function(value:T) : IObservable

		 ]]></param>
<return><![CDATA[An IObservable sequence containing the values returned

		 ]]></return>
</method>
<method name='merge' fullname='raix.reactive:IObservable/raix.reactive:IObservable:merge' isStatic='false' isFinal='false' isOverride='false'  param_names='source' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from multiple sources in the order that they arrive 

		 ]]></description>
<param><![CDATA[sources The other sequences from which the values will be merged with the current sequence

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use 

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='multiWindow' fullname='raix.reactive:IObservable/raix.reactive:IObservable:multiWindow' isStatic='false' isFinal='false' isOverride='false'  param_names='windowOpenings;windowClosingSelector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits values into child "window" observable sequences, which are opened and closed by the caller.

		 ]]></description>
<param><![CDATA[windowOpenings Signals the start of a new window by emitting a value

		 ]]></param>
<param><![CDATA[windowClosingSelector Returns an observable sequence that will signal the close of a window:

		 function (window : IObservable) : IObservable 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='multicastDefer' fullname='raix.reactive:IObservable/raix.reactive:IObservable:multicastDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='subjectSelector;selector' param_types='Function;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a connectable sequence that can be shared by multiple observers, using a specific 

		 subject implementation (determined at subscribe-time. The shared sequence will be passed 

		 to a selector function when the sequence is subscribed to.

		 ]]></description>
<param><![CDATA[subjectSelector Determines the subject to be used when the sequence is subscribed to

		 ]]></param>
<param><![CDATA[selector Accepts the yet-to-be-connected connectable sequence and returns the sequence 

		 that will supply values to the subject

		 ]]></param>
<return><![CDATA[An observable sequence that contains messages from the selector-returned sequence, piped 

		 through the subject supplied by subjectSelector

		 ]]></return>
</method>
<method name='multicast' fullname='raix.reactive:IObservable/raix.reactive:IObservable:multicast' isStatic='false' isFinal='false' isOverride='false'  param_names='subject' param_types='raix.reactive:ISubject' param_defaults='undefined' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 Creates a connectable sequence that can be shared by multiple observers, using a specific 

		 subject implementation. 

		 ]]></description>
<param><![CDATA[subject The subject that will messages and subscriptions

		 ]]></param>
<return><![CDATA[A connectable observable

		 ]]></return>
</method>
<method name='observeOn' fullname='raix.reactive:IObservable/raix.reactive:IObservable:observeOn' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Defers messages to subscribers through a scheduler  

		 ]]></description>
<param><![CDATA[scheduler The subscriber to send messages to subscribers through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='ofClass' fullname='raix.reactive:IObservable/raix.reactive:IObservable:ofClass' isStatic='false' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Filters out values from a source sequence that are not of a specific type 

		 ]]></description>
<param><![CDATA[valueClass The class (or subsclass) of all values to emit 

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='onErrorResumeNext' fullname='raix.reactive:IObservable/raix.reactive:IObservable:onErrorResumeNext' isStatic='false' isFinal='false' isOverride='false'  param_names='second;scheduler' param_types='raix.reactive:IObservable;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Subscribes down a list of sequence as each one errors or complete 

		 ]]></description>
<param><![CDATA[second The sequence to run after the current sequence completes or errors

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use to subscribe to the new sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='peekWith' fullname='raix.reactive:IObservable/raix.reactive:IObservable:peekWith' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Allows custom code to be run when messages arrive without affecting the observer

		 ]]></description>
<param><![CDATA[observer The observer that will receive messages

		 ]]></param>
</method>
<method name='peek' fullname='raix.reactive:IObservable/raix.reactive:IObservable:peek' isStatic='false' isFinal='false' isOverride='false'  param_names='next;complete;error' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Allows custom code to be run when messages arrive without affecting the observer  

		 ]]></description>
<param><![CDATA[next The function to execute in the event of a value (onNext)

		 ]]></param>
<param><![CDATA[complete The function to execute in the event the sequence completes (onComplete)

		 ]]></param>
<param><![CDATA[error The function to execute in the event of an error (onError)

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='pruneDefer' fullname='raix.reactive:IObservable/raix.reactive:IObservable:pruneDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;scheduler' param_types='Function;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a shared sequence that emits the last value of the source sequence, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to. 

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='prune' fullname='raix.reactive:IObservable/raix.reactive:IObservable:prune' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 Creates a shared sequence that emits the last value of the source sequence 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[A connectable observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='publishDefer' fullname='raix.reactive:IObservable/raix.reactive:IObservable:publishDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a shared sequence that can be used by multiple subscribers, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to.

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='publish' fullname='raix.reactive:IObservable/raix.reactive:IObservable:publish' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 Creates a connectable sequence that can be shared by multiple observers  

		 ]]></description>
<return><![CDATA[A connectable observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='reduce' fullname='raix.reactive:IObservable/raix.reactive:IObservable:reduce' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<description><![CDATA[ 

		 Runs calculation functions over every value in the source sequence and emits the final result

		 ]]></description>
<param><![CDATA[accumulator A function that accumulates the aggregate value: 

		     function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[initialValue The value to start with

		 ]]></param>
<return><![CDATA[An observable sequence of type TAccumulate

		 ]]></return>
</method>
<method name='removeTimeInterval' fullname='raix.reactive:IObservable/raix.reactive:IObservable:removeTimeInterval' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Removes time interval information added with timeInterval  

		 ]]></description>
<return><![CDATA[An observable sequence of the original values (without being wrapped in TimeInterval)

		 ]]></return>
</method>
<method name='removeTimestamp' fullname='raix.reactive:IObservable/raix.reactive:IObservable:removeTimestamp' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Removes timestamp information added with timestamp  

		 ]]></description>
<return><![CDATA[An observable sequence of the original values (without being wrapped in TimeStamp)

		 ]]></return>
</method>
<method name='repeat' fullname='raix.reactive:IObservable/raix.reactive:IObservable:repeat' isStatic='false' isFinal='false' isOverride='false'  param_names='repeatCount' param_types='uint' param_defaults='0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Repeats the source sequence a specific number of times 

		 ]]></description>
<param><![CDATA[repeatCount The number of times to repeat the sequence or 0 to repeat indefinitely

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='replayDefer' fullname='raix.reactive:IObservable/raix.reactive:IObservable:replayDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;bufferSize;windowMs;scheduler' param_types='Function;uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a shared sequence that replays values to future subscrubers, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through 

		 ]]></param>
<param><![CDATA[bufferSize The number of values at the end of the sequence to replay, or 0 for all.

		 ]]></param>
<param><![CDATA[windowMs The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='replay' fullname='raix.reactive:IObservable/raix.reactive:IObservable:replay' isStatic='false' isFinal='false' isOverride='false'  param_names='bufferSize;windowMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='0;0;null' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 Records the output of the source sequence and replays it to future subscribers 

		 ]]></description>
<param><![CDATA[bufferSize The number of values at the end of the sequence to replay, or 0 for all.

		 ]]></param>
<param><![CDATA[windowMs The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[A connectable observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='retry' fullname='raix.reactive:IObservable/raix.reactive:IObservable:retry' isStatic='false' isFinal='false' isOverride='false'  param_names='retryCount' param_types='uint' param_defaults='0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Repeats the source sequence when an error occurs 

		 ]]></description>
<param><![CDATA[retryCount The number of times to retry the sequence in the event of an error, 

		 or 0 to retry indefinitely

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='sample' fullname='raix.reactive:IObservable/raix.reactive:IObservable:sample' isStatic='false' isFinal='false' isOverride='false'  param_names='intervalMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the latest value on a time interval from a source sequence 

		 ]]></description>
<param><![CDATA[intervalMs The interval of time, in milliseconds, to sample the current value after

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='scan' fullname='raix.reactive:IObservable/raix.reactive:IObservable:scan' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 

		 ]]></description>
<param><![CDATA[accumulator The function that accumulates values

		 ]]></param>
<param><![CDATA[initialValue The value to start with

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='selectMany' fullname='raix.reactive:IObservable/raix.reactive:IObservable:selectMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values

		 ]]></description>
<param><![CDATA[selector The function to be executed with each value

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass result

		 ]]></return>
<metadata>
	<Deprecated owner='raix.reactive:IObservable/raix.reactive:IObservable:selectMany' replacement='mapMany' >
	</Deprecated>
</metadata>
</method>
<method name='sequenceEqual' fullname='raix.reactive:IObservable/raix.reactive:IObservable:sequenceEqual' isStatic='false' isFinal='false' isOverride='false'  param_names='other;valueComparer' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Determines whether two observable sequences are equal 

		 ]]></description>
<param><![CDATA[other The observable sequence to compare to

		 ]]></param>
<param><![CDATA[valueComparer The equality comparer to compare values between sequences:

		 function(value : TValue, otherValue : TOther) : Boolean

		 ]]></param>
<return><![CDATA[An observable sequence that will emit a single boolean value once equality has been determined

		 ]]></return>
</method>
<method name='singleOrDefault' fullname='raix.reactive:IObservable/raix.reactive:IObservable:singleOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the only item from a source sequence, the default value if no values are emitted, or

		 an error if more than one value is emitted.  

		 ]]></description>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='single' fullname='raix.reactive:IObservable/raix.reactive:IObservable:single' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 

		 ]]></description>
<return><![CDATA[An observable sequence

		 ]]></return>
</method>
<method name='skipLast' fullname='raix.reactive:IObservable/raix.reactive:IObservable:skipLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Ignores a set number of values from the end of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to skip from the end of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='skipUntil' fullname='raix.reactive:IObservable/raix.reactive:IObservable:skipUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='other' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Ignores values from a source sequence until a value is received from a specified sequence 

		 ]]></description>
<param><![CDATA[other The other sequence that will mark the start of values being used from the current sequence 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='skipWhile' fullname='raix.reactive:IObservable/raix.reactive:IObservable:skipWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Ignores values from a source sequence until a condition is no longer met

		 ]]></description>
<param><![CDATA[predicate The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='skip' fullname='raix.reactive:IObservable/raix.reactive:IObservable:skip' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Ignores a set number of values from the start of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to skip from the start of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='startWith' fullname='raix.reactive:IObservable/raix.reactive:IObservable:startWith' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='*' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the specified values at the start of a sequence 

		 ]]></description>
<param><![CDATA[value That value, converted to an IObservable using toObservable, that will 

		 be emitted at the start of the current sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
<see><![CDATA[raix.reactive.toObservable 

		 ]]></see>
</method>
<method name='subscribeOn' fullname='raix.reactive:IObservable/raix.reactive:IObservable:subscribeOn' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Defers subscriptions to the source through a scheduler  

		 ]]></description>
<param><![CDATA[scheduler The subscriber to schedule subscriptions through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='subscribeWith' fullname='raix.reactive:IObservable/raix.reactive:IObservable:subscribeWith' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<method name='subscribe' fullname='raix.reactive:IObservable/raix.reactive:IObservable:subscribe' isStatic='false' isFinal='false' isOverride='false'  param_names='onNext;onComplete;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Subscribes to this observable using the supplied functions 

		 ]]></description>
<param><![CDATA[onNext Function to be called for every value. Signature is <code>function(payload : T) : void</code>

		 ]]></param>
<param><![CDATA[onComplete Optional. Function to be called when the sequence completes. Signature is <code>function():void</code>

		 ]]></param>
<param><![CDATA[onError Optional. Function to be called when an error occurs in the sequence. Signature is <code>function(err:Error):void</code>

		 ]]></param>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<method name='sum' fullname='raix.reactive:IObservable/raix.reactive:IObservable:sum' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Returns the summed value of all the elements in the source sequence 

		 ]]></description>
<return><![CDATA[An observable sequence of Number

		 ]]></return>
</method>
<method name='switchMany' fullname='raix.reactive:IObservable/raix.reactive:IObservable:switchMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Like selectMany, starts a new sequence for every value in the source 

		 sequence but cancels the previous sequence each time.

		 ]]></description>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='takeLast' fullname='raix.reactive:IObservable/raix.reactive:IObservable:takeLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Takes only the last set number of values from a source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to use from the end of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='takeUntil' fullname='raix.reactive:IObservable/raix.reactive:IObservable:takeUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='other' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Takes values from a source sequence until a value is received from a specified sequence  

		 ]]></description>
<param><![CDATA[other The other sequence that will mark the end of values being used from the current sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='takeWhile' fullname='raix.reactive:IObservable/raix.reactive:IObservable:takeWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Takes values from a source sequence until a condition is no longer met 

		 ]]></description>
<param><![CDATA[predicate The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='take' fullname='raix.reactive:IObservable/raix.reactive:IObservable:take' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Takes only the first set number of values from a source sequenc

		 ]]></description>
<param><![CDATA[count The number of values to use from the start of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='then' fullname='raix.reactive:IObservable/raix.reactive:IObservable:then' isStatic='false' isFinal='false' isOverride='false'  param_names='thenFunction' param_types='Function' param_defaults='undefined' result_type='raix.reactive:Plan'>
<description><![CDATA[

		 Creates a Plan from this sequence, by supplying a 

		 valueClass and a mappingFunction for the values from each 

		 sequence in this Pattern 

		 ]]></description>
<param><![CDATA[thenFunction The function that will accept this sequence as an argument

		 ]]></param>
<return><![CDATA[A Plan that can be used with Observable.join

		 ]]></return>
</method>
<method name='throttle' fullname='raix.reactive:IObservable/raix.reactive:IObservable:throttle' isStatic='false' isFinal='false' isOverride='false'  param_names='dueTimeMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Limits how often values from a source sequence will be accepted from a source

		 ]]></description>
<param><![CDATA[intervalMs The interval of time, in milliseconds, during which only one value from the source sequence will be accepted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='timeInterval' fullname='raix.reactive:IObservable/raix.reactive:IObservable:timeInterval' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Includes, with every value emitted, the amount of time passed since the previous value 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use to determine time

		 ]]></param>
<return><![CDATA[An observable sequence of TimeInterval

		 ]]></return>
</method>
<method name='timeout' fullname='raix.reactive:IObservable/raix.reactive:IObservable:timeout' isStatic='false' isFinal='false' isOverride='false'  param_names='timeoutMs;other;scheduler' param_types='uint;raix.reactive:IObservable;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 

		 ]]></description>
<param><![CDATA[timeoutMs The amount of time, in milliseconds, after which to raise an error (or subscribe to other)

		 ]]></param>
<param><![CDATA[other The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='timestamp' fullname='raix.reactive:IObservable/raix.reactive:IObservable:timestamp' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of Timestamped 

		 ]]></return>
</method>
<method name='toArray' fullname='raix.reactive:IObservable/raix.reactive:IObservable:toArray' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Delivers all the results as a single array when the source completes 

		 ]]></description>
<return><![CDATA[An observable sequence of Array that will contain the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='windowWithCount' fullname='raix.reactive:IObservable/raix.reactive:IObservable:windowWithCount' isStatic='false' isFinal='false' isOverride='false'  param_names='count;skip' param_types='uint;uint' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[count The number of values to buffer

		 ]]></param>
<param><![CDATA[skip The number of values to offset after the buffer is emitted.

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='windowWithTimeOrCount' fullname='raix.reactive:IObservable/raix.reactive:IObservable:windowWithTimeOrCount' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;count;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first

		 ]]></description>
<param><![CDATA[timeMs The maximum amount of time for a child-sequence to capture values

		 ]]></param>
<param><![CDATA[count The maximum amount of values for a child-sequence to capture

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='windowWithTime' fullname='raix.reactive:IObservable/raix.reactive:IObservable:windowWithTime' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;timeShiftMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[timeMs The amount of time to buffer before the values are released

		 ]]></param>
<param><![CDATA[timeShiftMs The amount of time to offset after the buffer is emitted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='window' fullname='raix.reactive:IObservable/raix.reactive:IObservable:window' isStatic='false' isFinal='false' isOverride='false'  param_names='windowClosingSelector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Splits values into child-observable windows which are closed by the caller

		 ]]></description>
<param><![CDATA[windowClosingSelector Returns an IObservable that will emit a value or complete to indicate that the active 

		 		  window has closed. Called on subscription and immediately after each window closes. 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='zip' fullname='raix.reactive:IObservable/raix.reactive:IObservable:zip' isStatic='false' isFinal='false' isOverride='false'  param_names='rightSource;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Merges two sequences through a mapping function while only ever using each value once 

		 ]]></description>
<param><![CDATA[rightSource The sequence to combine with the current

		 ]]></param>
<param><![CDATA[selector The function to be executed when values are received from both sequences. The return value will be included in the output

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<classRec name='Observer' fullname='raix.reactive:Observer' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Observer.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Provides static methods that create observers

	 ]]></description>
</classRec>
<method name='Observer' fullname='raix.reactive:Observer/Observer' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='create' fullname='raix.reactive:Observer/create' isStatic='true' isFinal='false' isOverride='false'  param_names='onNext;onCompleted;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:IObserver'>
<description><![CDATA[

		 Creates an IObserver from onNext, onCompleted and onError functions

		 

		 ]]></description>
<param><![CDATA[onNext The function to call when a value is received

		 ]]></param>
<param><![CDATA[onCompleted The function to call when the sequence has complted

		 ]]></param>
<param><![CDATA[onError The function to call if an error occurs in the sequence 

		 ]]></param>
</method>
<classRec name='Cancelable' fullname='raix.reactive:Cancelable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Cancelable.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Provides static methods that create cancelable resources

	 ]]></description>
</classRec>
<method name='Cancelable' fullname='raix.reactive:Cancelable/Cancelable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='create' fullname='raix.reactive:Cancelable/create' isStatic='true' isFinal='false' isOverride='false'  param_names='action' param_types='Function' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Creates a cancelable resource that calls a function when canceled

		  

		 ]]></description>
<param><![CDATA[action The function to call when the resource is canceled 

		 ]]></param>
</method>
<method name='empty' fullname='raix.reactive:Cancelable/empty/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Returns a cancelable resource that does nothing when canceled

		 ]]></description>
</method>
<classRec name='OnError' fullname='raix.reactive:OnError' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\OnError.as' namespace='raix.reactive' access='public' baseclass='raix.reactive:Notification' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A Notification for an onError call

	 ]]></description>
</classRec>
<method name='OnError' fullname='raix.reactive:OnError/OnError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='*'>
</method>
<method name='accept' fullname='raix.reactive:OnError/accept' isStatic='false' isFinal='false' isOverride='true'  param_names='onNext;onCompleted;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='void'>
<description><![CDATA[

		 Calls onError if it's not null

		 ]]></description>
</method>
<method name='error' fullname='raix.reactive:OnError/error/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Error'>
<description><![CDATA[

		 Gets the error for this message 

		 ]]></description>
</method>
<method name='hasValue' fullname='raix.reactive:OnError/hasValue/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Boolean'>
<description><![CDATA[

		 Always returns false since no values are associated with errors 

		 ]]></description>
</method>
<method name='kind' fullname='raix.reactive:OnError/kind/get' isStatic='false' isFinal='false' isOverride='true'  result_type='int'>
<description><![CDATA[

		 Always returns NotificationKind.ON_ERROR 

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:OnError/value/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Object'>
<description><![CDATA[

		 Always returns null since no values are associated with errors 

		 ]]></description>
</method>
<field name='_error' fullname='raix.reactive:OnError/private:_error' type='Error' isStatic='false' isConst='false' >
</field>
<interfaceRec name='IGroupedObservable' fullname='raix.reactive:IGroupedObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\IGroupedObservable.as' namespace='raix.reactive' access='public' baseClasses='raix.reactive:IObservable' isFinal='false' isDynamic='false' >
</interfaceRec>
<method name='key' fullname='raix.reactive:IGroupedObservable/raix.reactive:IGroupedObservable:key/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
</method>
<classRec name='OnCompleted' fullname='raix.reactive:OnCompleted' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\OnCompleted.as' namespace='raix.reactive' access='public' baseclass='raix.reactive:Notification' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A Notification for an onCompleted call

	 ]]></description>
</classRec>
<method name='OnCompleted' fullname='raix.reactive:OnCompleted/OnCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='accept' fullname='raix.reactive:OnCompleted/accept' isStatic='false' isFinal='false' isOverride='true'  param_names='onNext;onCompleted;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='void'>
<description><![CDATA[

		 Calls onCompleted if it's not null

		 ]]></description>
</method>
<method name='error' fullname='raix.reactive:OnCompleted/error/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Error'>
<description><![CDATA[

		 Always returns false since no errors are associated with completion 

		 ]]></description>
</method>
<method name='hasValue' fullname='raix.reactive:OnCompleted/hasValue/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Boolean'>
<description><![CDATA[

		 Always returns false since no values are associated with completion 

		 ]]></description>
</method>
<method name='kind' fullname='raix.reactive:OnCompleted/kind/get' isStatic='false' isFinal='false' isOverride='true'  result_type='int'>
<description><![CDATA[

		 Always returns NotificationKind.ON_COMPLETED 

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:OnCompleted/value/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Object'>
<description><![CDATA[

		 Always returns null since no values are associated with completion 

		 ]]></description>
</method>
<interfaceRec name='ISubject' fullname='raix.reactive:ISubject' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\ISubject.as' namespace='raix.reactive' access='public' baseClasses='raix.reactive:IObservable;raix.reactive:IObserver' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A resource that is both observable and an observer

	 ]]></description>
</interfaceRec>
<classRec name='OnNext' fullname='raix.reactive:OnNext' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\OnNext.as' namespace='raix.reactive' access='public' baseclass='raix.reactive:Notification' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A Notification for an onNext call

	 ]]></description>
</classRec>
<method name='OnNext' fullname='raix.reactive:OnNext/OnNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='*'>
</method>
<method name='accept' fullname='raix.reactive:OnNext/accept' isStatic='false' isFinal='false' isOverride='true'  param_names='onNext;onCompleted;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='void'>
<description><![CDATA[

		 Calls onNext if it's not null

		 ]]></description>
</method>
<method name='error' fullname='raix.reactive:OnNext/error/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Error'>
<description><![CDATA[

		 Always returns false since no errors are associated with values 

		 ]]></description>
</method>
<method name='hasValue' fullname='raix.reactive:OnNext/hasValue/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Boolean'>
<description><![CDATA[

		 Always returns true 

		 ]]></description>
</method>
<method name='kind' fullname='raix.reactive:OnNext/kind/get' isStatic='false' isFinal='false' isOverride='true'  result_type='int'>
<description><![CDATA[

		 Always returns NotificationKind.ON_NEXT 

		 ]]></description>
</method>
<method name='value' fullname='raix.reactive:OnNext/value/get' isStatic='false' isFinal='false' isOverride='true'  result_type='Object'>
<description><![CDATA[

		 Gets the value from the message 

		 ]]></description>
</method>
<field name='_value' fullname='raix.reactive:OnNext/private:_value' type='Object' isStatic='false' isConst='false' >
</field>
<method name='toObservable' fullname='raix.reactive:toObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='args' param_types='restParam' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

	 Converts a value to an IObservable sequence. It can be considered to have the following overloads:

	 

	 <ul>

	 <li>function():IObservable - returns an empty sequence</li>

	 <li>function(array : Array):Observable - returns a sequence that wraps an array</li>

	 <li>function(observable : IObservable):IObservable - returns observable</li>

	 <li>function(enumerable : IEnumerable):IObservable - returns a sequence that wraps eumerable</li>

	 <li>function(error : Error):IObservable - returns a sequence will error when subscribed to</li>

	 <li>function(value : :IEnumerable - returns enumerable that contains a single value</li>

	 </ul>

	 ]]></description>
</method>
<classRec name='AbsObservable' fullname='raix.reactive:AbsObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\AbsObservable.as' namespace='raix.reactive' access='public' baseclass='Object' interfaces='raix.reactive:IObservable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Subclass this class only if you want to implement a completely custom IObservable.

	 

	 <p>If you can avoid it, however, try to stick to subclassing Subject or using 

	 one of the creation methods.</p>

	 

	 <p>This class may be made inaccessible in future revisions</p>

	 ]]></description>
</classRec>
<method name='AbsObservable' fullname='raix.reactive:AbsObservable/AbsObservable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='aggregate' fullname='raix.reactive:AbsObservable/aggregate' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 ]]></description>
</method>
<method name='all' fullname='raix.reactive:AbsObservable/all' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Determines if all values in the source sequence satisfy a condition

		 ]]></description>
<param><![CDATA[predicate The predicate that determines if a value in the sequence is valid. 

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='and' fullname='raix.reactive:AbsObservable/and' isStatic='false' isFinal='false' isOverride='false'  param_names='right' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:Pattern'>
<description><![CDATA[

		  

		 Creates a pattern by combining the current source with right.

		 

		 ]]></description>
<param><![CDATA[right The other sequence to combine with the pattern.

		 ]]></param>
<return><![CDATA[A pattern representing both sequences

		 ]]></return>
</method>
<method name='any' fullname='raix.reactive:AbsObservable/any' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Determines if the source sequence contains a value that satisfies a condition

		  

		 ]]></description>
<param><![CDATA[predicate (optional) The predicate that determines if a value in the sequence is valid. 

		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='asObservable' fullname='raix.reactive:AbsObservable/asObservable' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='average' fullname='raix.reactive:AbsObservable/average' isStatic='false' isFinal='false' isOverride='false'  param_names='valueSelector' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Returns the average value of all the elements in the source sequence

		 ]]></description>
<param><![CDATA[valueSelector (optional) The selector function that returns a numeric value from the source value  

		 ]]></param>
<return><![CDATA[An observable sequence of TSource values

		 ]]></return>
</method>
<method name='bufferWithCount' fullname='raix.reactive:AbsObservable/bufferWithCount' isStatic='false' isFinal='false' isOverride='false'  param_names='count;skip' param_types='uint;uint' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[count The number of values to buffer

		 ]]></param>
<param><![CDATA[skip The number of values to offset after the buffer is emitted.

		 ]]></param>
<return><![CDATA[An observable sequence of arrays of the the same type as the current sequence

		 ]]></return>
</method>
<method name='bufferWithTimeOrCount' fullname='raix.reactive:AbsObservable/bufferWithTimeOrCount' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;count;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 

		 of values, whichever occurs first

		 ]]></description>
<param><![CDATA[timeMs The maximum amount of time to buffer values for

		 ]]></param>
<param><![CDATA[count The maximum amount of values to include in a single buffer

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='bufferWithTime' fullname='raix.reactive:AbsObservable/bufferWithTime' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;timeShiftMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[timeMs The amount of time to buffer before the values are released

		 ]]></param>
<param><![CDATA[timeShiftMs The amount of time to offset after the buffer is emitted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of Arrays of the same type as the current sequence

		 ]]></return>
</method>
<method name='cast' fullname='raix.reactive:AbsObservable/cast' isStatic='false' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Forces values from a source sequence to be of a specific class

		 ]]></description>
<param><![CDATA[valueClass The valueClass of the output sequence

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass 

		 ]]></return>
</method>
<method name='catchErrorDefer' fullname='raix.reactive:AbsObservable/catchErrorDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='errorClass;deferFunc' param_types='Class;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Runs a specific sequence, determined at runtime, when an error occurs

		 ]]></description>
<param><![CDATA[errorClass The class (and superclass) of error to act on

		 ]]></param>
<param><![CDATA[deferFunc The function to execute in the event of an error. 

		 Signature is <code>function(e : Error) : IObservable</code>

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='catchError' fullname='raix.reactive:AbsObservable/catchError' isStatic='false' isFinal='false' isOverride='false'  param_names='second' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Runs a specific sequence when an error occurs

		 ]]></description>
<param><![CDATA[second The sequence to subscribe to when an error occurs

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='chain' fullname='raix.reactive:AbsObservable/chain' isStatic='false' isFinal='false' isOverride='false'  param_names='functions' param_types='Array' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Chains together sequences, starting with the current sequence, using selector functions that 

		 return a sequence for values of the previous.

		 ]]></description>
<param><![CDATA[functions An array of functions that accept a value from the previous sequence and 

		        return a new sequence:

		        function (value : T) : IObservable

		 ]]></param>
<return><![CDATA[An observable sequence of the values returned by the sequence returned by the last 

		 selector in the chain

		 ]]></return>
</method>
<method name='combineLatest' fullname='raix.reactive:AbsObservable/combineLatest' isStatic='false' isFinal='false' isOverride='false'  param_names='right;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Merges two sequences through a mapping function, using the latest value from either source 

		 ]]></description>
<param><![CDATA[right The sequence to combine with

		 ]]></param>
<param><![CDATA[selector The function that combines values from the two sources. Signature is <code>function(left : this.valueClass, right : right.valueClass) : returnType</code>

		 ]]></param>
<return><![CDATA[An observable sequence of returnType 

		 ]]></return>
</method>
<method name='concatMany' fullname='raix.reactive:AbsObservable/concatMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Evaluates a new sequence for each value using a selector function and waits for the returned 

		 sequence to complete before resolving the next sequence 

		 ]]></description>
<param><![CDATA[selector Accept a value of the source and returns the IObservable sequence to concatonate:

		     function(value:T) : IObservable

		 ]]></param>
<return><![CDATA[An IObservable sequence containing the values returned

		 ]]></return>
</method>
<method name='concat' fullname='raix.reactive:AbsObservable/concat' isStatic='false' isFinal='false' isOverride='false'  param_names='source' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Concatonates multiple sequences by running each sequence as the previous one finishes

		 ]]></description>
<param><![CDATA[sources The sequences to concatonate after the current sequence 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='contains' fullname='raix.reactive:AbsObservable/contains' isStatic='false' isFinal='false' isOverride='false'  param_names='value;comparer' param_types='Object;Function' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Determines if the source sequence contains a specific value 

		 ]]></description>
<param><![CDATA[value The value to check against the sequence

		 ]]></param>
<param><![CDATA[comparer The function used to compare values. Default equality will be used if comparer is null.

		 ]]></param>
<return><![CDATA[An observable sequence of Boolean

		 ]]></return>
</method>
<method name='count' fullname='raix.reactive:AbsObservable/count' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Returns the number of elements in the source sequence 

		 ]]></description>
<return><![CDATA[An observable sequence of int

		 ]]></return>
</method>
<method name='delayUntil' fullname='raix.reactive:AbsObservable/delayUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='dt;scheduler' param_types='Date;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 ]]></description>
<inheritDoc><![CDATA[]]></inheritDoc>
</method>
<method name='delay' fullname='raix.reactive:AbsObservable/delay' isStatic='false' isFinal='false' isOverride='false'  param_names='delayMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Delays all values in a sequences by a specified time 

		 ]]></description>
<param><![CDATA[delayMs The amount of time, in milliseconds, to delay

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to delay the values

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='dematerialize' fullname='raix.reactive:AbsObservable/dematerialize' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Converts materialized values back into messages  

		 ]]></description>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='distinctUntilChanged' fullname='raix.reactive:AbsObservable/distinctUntilChanged' isStatic='false' isFinal='false' isOverride='false'  param_names='comparer' param_types='Function' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Filters out consecutive duplicates from a source sequence  

		 ]]></description>
<param><![CDATA[comparer (optional) The function used to compare values. Default equality will be used if comparer is null.

		 function(x:TValue, y:TValue) : Boolean

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='expand' fullname='raix.reactive:AbsObservable/expand' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Recursively expands the values in the sequence using a selector function 

		 ]]></description>
<param><![CDATA[selector Accepts values and returns an expanded sequence for them:

		     function (value : T) : IObservable

		 ]]></param>
<return><![CDATA[An observable sequence of all values emitted by any of the sequences

		 ]]></return>
</method>
<method name='filter' fullname='raix.reactive:AbsObservable/filter' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Filters out values from a source sequence 

		 ]]></description>
<param><![CDATA[predicate The predicate function to execute for each value to determine if it will be include in the output

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='finallyAction' fullname='raix.reactive:AbsObservable/finallyAction' isStatic='false' isFinal='false' isOverride='false'  param_names='action' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Executes a function when the sequence completes, errors or is unsubscribed from

		 ]]></description>
<param><![CDATA[finallyAction The function to execute in the event the sequence completes or errors

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='firstOrDefault' fullname='raix.reactive:AbsObservable/firstOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the first value in the sequence, or a default value if the sequence completes with no values

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='first' fullname='raix.reactive:AbsObservable/first' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the first value in the sequence, or an error if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='forkJoin' fullname='raix.reactive:AbsObservable/forkJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='right;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Combines the current sequence with another, emitting the last values of both after both have completed 

		 ]]></description>
<param><![CDATA[right The sequence to subscribe to, along with the current sequence

		 ]]></param>
<param><![CDATA[selector The function that accepts the last values of both sequences and returns the output value:

		     function(left : TLeft, right : TRight) : TResult 

		 ]]></param>
<return><![CDATA[An observable sequence of TResult

		 ]]></return>
</method>
<method name='groupByUntil' fullname='raix.reactive:AbsObservable/groupByUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;durationSelector;elementSelector;keyComparer' param_types='Function;Function;Function;Function' param_defaults='undefined;undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Groups values by a key and also provides a lifetime for a grouping

		 ]]></description>
<param><![CDATA[keySelector A selector that maps the key from a source value:

		     function(value:TValue):TKey

		 ]]></param>
<param><![CDATA[durationSelector A selector that returns an observable sequence that will signal 

		     the end of the life of a group by emitting a value or completing:

		     function(group:IGroupedObservable) : IObservable

		 ]]></param>
<param><![CDATA[elementSelector (optional) A selector that maps the source value to the element value that 

		     will be added to the grouped items: function(value:TValue):TElement

		 ]]></param>
<param><![CDATA[keyComparer A equality comparer that compares two keys

		 ]]></param>
<return><![CDATA[An observable sequence of IGroupedObservable

		 ]]></return>
</method>
<method name='groupBy' fullname='raix.reactive:AbsObservable/groupBy' isStatic='false' isFinal='false' isOverride='false'  param_names='keySelector;elementSelector;keyComparer' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Groups values by a key

		 ]]></description>
<param><![CDATA[keySelector A selector that maps the key from a source value:

		     function(value:TValue):TKey

		 ]]></param>
<param><![CDATA[elementSelector (optional) A selector that maps the source value to the element value that 

		     will be added to the grouped items: function(value:TValue):TElement

		 ]]></param>
<param><![CDATA[keyComparer A equality comparer that compares two keys

		 ]]></param>
<return><![CDATA[An observable sequence of IGroupedObservable

		 ]]></return>
</method>
<method name='groupJoin' fullname='raix.reactive:AbsObservable/groupJoin' isStatic='false' isFinal='false' isOverride='false'  param_names='right;leftWindowSelector;rightWindowSelector;joinSelector' param_types='raix.reactive:IObservable;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 

		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value

		 to a selector to be combined. The output of this selector is emitted to the output stream  

		 ]]></description>
<param><![CDATA[right The right hand side of the join

		 ]]></param>
<param><![CDATA[leftWindowSelector A function that will be called for each value from the left ("this") and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(left:TLeft):IObservable

		 ]]></param>
<param><![CDATA[rightWindowSelector A function that will be called for each value from right and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(right:TRight):IObservable

		 ]]></param>
<param><![CDATA[joinSelector A function that will accept "live" left/right value combinations and return a new value. 

		     The output of this function will be received by any subscribers:

		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult

		 ]]></param>
<return><![CDATA[An observable sequence of TResult values

		 ]]></return>
</method>
<method name='ignoreValues' fullname='raix.reactive:AbsObservable/ignoreValues' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 

		 ]]></description>
<return><![CDATA[An observable sequence

		 ]]></return>
</method>
<method name='join' fullname='raix.reactive:AbsObservable/join' isStatic='false' isFinal='false' isOverride='false'  param_names='right;leftWindowSelector;rightWindowSelector;joinSelector' param_types='raix.reactive:IObservable;Function;Function;Function' param_defaults='undefined;undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 

		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 

		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  

		 ]]></description>
<param><![CDATA[right The right hand side of the join

		 ]]></param>
<param><![CDATA[leftWindowSelector A function that will be called for each value from the left ("this") and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(left:TLeft):IObservable

		 ]]></param>
<param><![CDATA[rightWindowSelector A function that will be called for each value from right and will 

		     return the IObservable that represents the lifetime window of that value:

		     function(right:TRight):IObservable

		 ]]></param>
<param><![CDATA[joinSelector A function that will accept "live" left/right value combinations and return a new value. 

		     The output of this function will be received by any subscribers:

		     function(left : TLeft, right : TRight) : TResult

		 ]]></param>
<return><![CDATA[An observable sequence of TResult (returned by joinSelector)

		 ]]></return>
</method>
<method name='lastOrDefault' fullname='raix.reactive:AbsObservable/lastOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the last value in the sequence, or the default value if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='last' fullname='raix.reactive:AbsObservable/last' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the last value in the sequence, or an error if the sequence completes with no values 

		 ]]></description>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='let' fullname='raix.reactive:AbsObservable/let' isStatic='false' isFinal='false' isOverride='false'  param_names='func' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 

		 ]]></description>
<param><![CDATA[func The function to send the current sequence through, and return a new sequence 

		 ]]></param>
<return><![CDATA[The observable sequence returned by func 

		 ]]></return>
</method>
<method name='log' fullname='raix.reactive:AbsObservable/log' isStatic='false' isFinal='false' isOverride='false'  param_names='message' param_types='String' param_defaults='undefined' result_type='raix.reactive:IObservable'>
</method>
<method name='mapInternal' fullname='raix.reactive:AbsObservable/private:mapInternal' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
</method>
<method name='mapMany' fullname='raix.reactive:AbsObservable/mapMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values

		 ]]></description>
<param><![CDATA[valueClass The valueClass of the sequences returned by selector

		 ]]></param>
<param><![CDATA[selector The function that maps values to new observable sequences that will 

		 be merged in the result set: function(value:TValue):IObservable

		 ]]></param>
<return><![CDATA[An observable sequence containing the values emitted from the child observable sequences

		 ]]></return>
</method>
<method name='map' fullname='raix.reactive:AbsObservable/map' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Maps the values from a source sequence through a function to change their value  

		 ]]></description>
<param><![CDATA[selector The function to be executed with each value

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass result

		 ]]></return>
</method>
<method name='materialize' fullname='raix.reactive:AbsObservable/materialize' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Converts all messages (next, complete, error) into values 

		 ]]></description>
<return><![CDATA[An observable sequence of rx.Notification

		 ]]></return>
</method>
<method name='mergeMany' fullname='raix.reactive:AbsObservable/mergeMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;concurrent' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Evaluates a new sequence for each value using a selector function and merges the results 

		 of the sequence returned by the returned sequence, optionally constraining the number of 

		 concurrent sequencing.

		 ]]></description>
<param><![CDATA[selector Accept a value of the source and returns the IObservable sequence to merge:

		     function(value:T) : IObservable

		 ]]></param>
<return><![CDATA[An IObservable sequence containing the values returned

		 ]]></return>
</method>
<method name='merge' fullname='raix.reactive:AbsObservable/merge' isStatic='false' isFinal='false' isOverride='false'  param_names='source' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the values from multiple sources in the order that they arrive 

		 ]]></description>
<param><![CDATA[sources The other sequences from which the values will be merged with the current sequence

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use 

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='multiWindow' fullname='raix.reactive:AbsObservable/multiWindow' isStatic='false' isFinal='false' isOverride='false'  param_names='windowOpenings;windowClosingSelector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits values into child "window" observable sequences, which are opened and closed by the caller.

		 ]]></description>
<param><![CDATA[windowOpenings Signals the start of a new window by emitting a value

		 ]]></param>
<param><![CDATA[windowClosingSelector Returns an observable sequence that will signal the close of a window:

		 function (window : IObservable) : IObservable 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='multicastDefer' fullname='raix.reactive:AbsObservable/multicastDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='subjectSelector;selector' param_types='Function;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Creates a connectable sequence that can be shared by multiple observers, using a specific 

		 subject implementation (determined at subscribe-time. The shared sequence will be passed 

		 to a selector function when the sequence is subscribed to.

		 ]]></description>
<param><![CDATA[subjectSelector Determines the subject to be used when the sequence is subscribed to

		 ]]></param>
<param><![CDATA[selector Accepts the yet-to-be-connected connectable sequence and returns the sequence 

		 that will supply values to the subject

		 ]]></param>
<return><![CDATA[An observable sequence that contains messages from the selector-returned sequence, piped 

		 through the subject supplied by subjectSelector

		 ]]></return>
</method>
<method name='multicast' fullname='raix.reactive:AbsObservable/multicast' isStatic='false' isFinal='false' isOverride='false'  param_names='subject' param_types='raix.reactive:ISubject' param_defaults='undefined' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 

		 Creates a connectable sequence that can be shared by multiple observers, using a specific 

		 subject implementation. 

		 ]]></description>
<param><![CDATA[subject The subject that will messages and subscriptions

		 ]]></param>
<return><![CDATA[A connectable observable

		 ]]></return>
</method>
<method name='normalizeComparer' fullname='raix.reactive:AbsObservable/private:normalizeComparer' isStatic='true' isFinal='false' isOverride='false'  param_names='source' param_types='Function' param_defaults='undefined' result_type='Function'>
</method>
<method name='observeOn' fullname='raix.reactive:AbsObservable/observeOn' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Defers messages to subscribers through a scheduler  

		 ]]></description>
<param><![CDATA[scheduler The subscriber to send messages to subscribers through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='ofClass' fullname='raix.reactive:AbsObservable/ofClass' isStatic='false' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Filters out values from a source sequence that are not of a specific type 

		 ]]></description>
<param><![CDATA[valueClass The class (or subsclass) of all values to emit 

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='onErrorResumeNext' fullname='raix.reactive:AbsObservable/onErrorResumeNext' isStatic='false' isFinal='false' isOverride='false'  param_names='second;scheduler' param_types='raix.reactive:IObservable;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Subscribes down a list of sequence as each one errors or complete 

		 ]]></description>
<param><![CDATA[second The sequence to run after the current sequence completes or errors

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use to subscribe to the new sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='peekWith' fullname='raix.reactive:AbsObservable/peekWith' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Allows custom code to be run when messages arrive without affecting the observer

		 ]]></description>
<param><![CDATA[observer The observer that will receive messages

		 ]]></param>
</method>
<method name='peek' fullname='raix.reactive:AbsObservable/peek' isStatic='false' isFinal='false' isOverride='false'  param_names='nextAction;completeAction;errorAction' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Allows custom code to be run when messages arrive without affecting the observer  

		 ]]></description>
<param><![CDATA[next The function to execute in the event of a value (onNext)

		 ]]></param>
<param><![CDATA[complete The function to execute in the event the sequence completes (onComplete)

		 ]]></param>
<param><![CDATA[error The function to execute in the event of an error (onError)

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='pruneDefer' fullname='raix.reactive:AbsObservable/pruneDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;scheduler' param_types='Function;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Creates a shared sequence that emits the last value of the source sequence, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to. 

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='prune' fullname='raix.reactive:AbsObservable/prune' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 

		 Creates a shared sequence that emits the last value of the source sequence 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[A connectable observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='publishDefer' fullname='raix.reactive:AbsObservable/publishDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Creates a shared sequence that can be used by multiple subscribers, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to.

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='publish' fullname='raix.reactive:AbsObservable/publish' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 

		 Creates a connectable sequence that can be shared by multiple observers  

		 ]]></description>
<return><![CDATA[A connectable observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='reduce' fullname='raix.reactive:AbsObservable/reduce' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		  

		 Runs calculation functions over every value in the source sequence and emits the final result

		 ]]></description>
<param><![CDATA[accumulator A function that accumulates the aggregate value: 

		     function(accumulate : TAccumulate, element : TElement) : TAccumulate

		 ]]></param>
<param><![CDATA[initialValue The value to start with

		 ]]></param>
<return><![CDATA[An observable sequence of type TAccumulate

		 ]]></return>
</method>
<method name='removeTimeInterval' fullname='raix.reactive:AbsObservable/removeTimeInterval' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Removes time interval information added with timeInterval  

		 ]]></description>
<return><![CDATA[An observable sequence of the original values (without being wrapped in TimeInterval)

		 ]]></return>
</method>
<method name='removeTimestamp' fullname='raix.reactive:AbsObservable/removeTimestamp' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Removes timestamp information added with timestamp  

		 ]]></description>
<return><![CDATA[An observable sequence of the original values (without being wrapped in TimeStamp)

		 ]]></return>
</method>
<method name='repeat' fullname='raix.reactive:AbsObservable/repeat' isStatic='false' isFinal='false' isOverride='false'  param_names='repeatCount' param_types='uint' param_defaults='0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Repeats the source sequence a specific number of times 

		 ]]></description>
<param><![CDATA[repeatCount The number of times to repeat the sequence or 0 to repeat indefinitely

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='replayDefer' fullname='raix.reactive:AbsObservable/replayDefer' isStatic='false' isFinal='false' isOverride='false'  param_names='selector;bufferSize;windowMs;scheduler' param_types='Function;uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Creates a shared sequence that replays values to future subscrubers, the shared 

		 sequence will be passed to the selector function when the sequence is subscribed to

		 ]]></description>
<param><![CDATA[selector The function to map the connected sequence through 

		 ]]></param>
<param><![CDATA[bufferSize The number of values at the end of the sequence to replay, or 0 for all.

		 ]]></param>
<param><![CDATA[windowMs The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='replay' fullname='raix.reactive:AbsObservable/replay' isStatic='false' isFinal='false' isOverride='false'  param_names='bufferSize;windowMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='0;0;null' result_type='raix.reactive.subjects:IConnectableObservable'>
<description><![CDATA[

		 

		 Records the output of the source sequence and replays it to future subscribers 

		 ]]></description>
<param><![CDATA[bufferSize The number of values at the end of the sequence to replay, or 0 for all.

		 ]]></param>
<param><![CDATA[windowMs The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[A connectable observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='retry' fullname='raix.reactive:AbsObservable/retry' isStatic='false' isFinal='false' isOverride='false'  param_names='retryCount' param_types='uint' param_defaults='0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Repeats the source sequence when an error occurs 

		 ]]></description>
<param><![CDATA[retryCount The number of times to retry the sequence in the event of an error, 

		 or 0 to retry indefinitely

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence 

		 ]]></return>
</method>
<method name='sample' fullname='raix.reactive:AbsObservable/sample' isStatic='false' isFinal='false' isOverride='false'  param_names='intervalMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the latest value on a time interval from a source sequence 

		 ]]></description>
<param><![CDATA[intervalMs The interval of time, in milliseconds, to sample the current value after

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='scan' fullname='raix.reactive:AbsObservable/scan' isStatic='false' isFinal='false' isOverride='false'  param_names='accumulator;initialValue;useInitialValue' param_types='Function;Object;Boolean' param_defaults='undefined;null;false' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 

		 ]]></description>
<param><![CDATA[accumulator The function that accumulates values

		 ]]></param>
<param><![CDATA[initialValue The value to start with

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='selectMany' fullname='raix.reactive:AbsObservable/selectMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values

		 ]]></description>
<param><![CDATA[selector The function to be executed with each value

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass result

		 ]]></return>
<metadata>
	<Deprecated owner='raix.reactive:AbsObservable/selectMany' replacement='mapMany' >
	</Deprecated>
</metadata>
</method>
<method name='select' fullname='raix.reactive:AbsObservable/select' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 ]]></description>
<inheritDoc><![CDATA[]]></inheritDoc>
<metadata>
	<Deprecated owner='raix.reactive:AbsObservable/select' replacement='map' >
	</Deprecated>
</metadata>
</method>
<method name='sequenceEqual' fullname='raix.reactive:AbsObservable/sequenceEqual' isStatic='false' isFinal='false' isOverride='false'  param_names='other;valueComparer' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Determines whether two observable sequences are equal 

		 ]]></description>
<param><![CDATA[other The observable sequence to compare to

		 ]]></param>
<param><![CDATA[valueComparer The equality comparer to compare values between sequences:

		 function(value : TValue, otherValue : TOther) : Boolean

		 ]]></param>
<return><![CDATA[An observable sequence that will emit a single boolean value once equality has been determined

		 ]]></return>
</method>
<method name='singleOrDefault' fullname='raix.reactive:AbsObservable/singleOrDefault' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the only item from a source sequence, the default value if no values are emitted, or

		 an error if more than one value is emitted.  

		 ]]></description>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='single' fullname='raix.reactive:AbsObservable/single' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 

		 ]]></description>
<return><![CDATA[An observable sequence

		 ]]></return>
</method>
<method name='skipLast' fullname='raix.reactive:AbsObservable/skipLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Ignores a set number of values from the end of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to skip from the end of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='skipUntil' fullname='raix.reactive:AbsObservable/skipUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='other' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Ignores values from a source sequence until a value is received from a specified sequence 

		 ]]></description>
<param><![CDATA[other The other sequence that will mark the start of values being used from the current sequence 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='skipWhile' fullname='raix.reactive:AbsObservable/skipWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Ignores values from a source sequence until a condition is no longer met

		 ]]></description>
<param><![CDATA[predicate The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='skip' fullname='raix.reactive:AbsObservable/skip' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Ignores a set number of values from the start of the source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to skip from the start of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='startWith' fullname='raix.reactive:AbsObservable/startWith' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='*' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the specified values at the start of a sequence 

		 ]]></description>
<param><![CDATA[value That value, converted to an IObservable using toObservable, that will 

		 be emitted at the start of the current sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='subscribeOn' fullname='raix.reactive:AbsObservable/subscribeOn' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Defers subscriptions to the source through a scheduler  

		 ]]></description>
<param><![CDATA[scheduler The subscriber to schedule subscriptions through

		 ]]></param>
<return><![CDATA[An observable sequence of the same type as the current sequence

		 ]]></return>
</method>
<method name='subscribeWith' fullname='raix.reactive:AbsObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<method name='subscribe' fullname='raix.reactive:AbsObservable/subscribe' isStatic='false' isFinal='false' isOverride='false'  param_names='onNext;onComplete;onError' param_types='Function;Function;Function' param_defaults='undefined;null;null' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied functions 

		 ]]></description>
<param><![CDATA[onNext Function to be called for every value. Signature is <code>function(payload : T) : void</code>

		 ]]></param>
<param><![CDATA[onComplete Optional. Function to be called when the sequence completes. Signature is <code>function():void</code>

		 ]]></param>
<param><![CDATA[onError Optional. Function to be called when an error occurs in the sequence. Signature is <code>function(err:Error):void</code>

		 ]]></param>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<method name='sum' fullname='raix.reactive:AbsObservable/sum' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Returns the summed value of all the elements in the source sequence 

		 ]]></description>
<return><![CDATA[An observable sequence of Number

		 ]]></return>
</method>
<method name='switchMany' fullname='raix.reactive:AbsObservable/switchMany' isStatic='false' isFinal='false' isOverride='false'  param_names='selector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Like selectMany, starts a new sequence for every value in the source 

		 sequence but cancels the previous sequence each time.

		 ]]></description>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='takeLast' fullname='raix.reactive:AbsObservable/takeLast' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Takes only the last set number of values from a source sequence 

		 ]]></description>
<param><![CDATA[count The number of values to use from the end of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='takeUntil' fullname='raix.reactive:AbsObservable/takeUntil' isStatic='false' isFinal='false' isOverride='false'  param_names='other' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Takes values from a source sequence until a value is received from a specified sequence  

		 ]]></description>
<param><![CDATA[other The other sequence that will mark the end of values being used from the current sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='takeWhile' fullname='raix.reactive:AbsObservable/takeWhile' isStatic='false' isFinal='false' isOverride='false'  param_names='predicate' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Takes values from a source sequence until a condition is no longer met 

		 ]]></description>
<param><![CDATA[predicate The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='take' fullname='raix.reactive:AbsObservable/take' isStatic='false' isFinal='false' isOverride='false'  param_names='count' param_types='uint' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Takes only the first set number of values from a source sequenc

		 ]]></description>
<param><![CDATA[count The number of values to use from the start of the sequence

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='then' fullname='raix.reactive:AbsObservable/then' isStatic='false' isFinal='false' isOverride='false'  param_names='thenFunction' param_types='Function' param_defaults='undefined' result_type='raix.reactive:Plan'>
<description><![CDATA[

		 

		 Creates a Plan from this sequence, by supplying a 

		 valueClass and a mappingFunction for the values from each 

		 sequence in this Pattern 

		 ]]></description>
<param><![CDATA[thenFunction The function that will accept this sequence as an argument

		 ]]></param>
<return><![CDATA[A Plan that can be used with Observable.join

		 ]]></return>
</method>
<method name='throttle' fullname='raix.reactive:AbsObservable/throttle' isStatic='false' isFinal='false' isOverride='false'  param_names='dueTimeMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Limits how often values from a source sequence will be accepted from a source

		 ]]></description>
<param><![CDATA[intervalMs The interval of time, in milliseconds, during which only one value from the source sequence will be accepted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='timeInterval' fullname='raix.reactive:AbsObservable/timeInterval' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Includes, with every value emitted, the amount of time passed since the previous value 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use to determine time

		 ]]></param>
<return><![CDATA[An observable sequence of TimeInterval

		 ]]></return>
</method>
<method name='timeout' fullname='raix.reactive:AbsObservable/timeout' isStatic='false' isFinal='false' isOverride='false'  param_names='timeoutMs;other;scheduler' param_types='uint;raix.reactive:IObservable;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 

		 ]]></description>
<param><![CDATA[timeoutMs The amount of time, in milliseconds, after which to raise an error (or subscribe to other)

		 ]]></param>
<param><![CDATA[other The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence 

		 ]]></return>
</method>
<method name='timestamp' fullname='raix.reactive:AbsObservable/timestamp' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of Timestamped 

		 ]]></return>
</method>
<method name='toArray' fullname='raix.reactive:AbsObservable/toArray' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Delivers all the results as a single array when the source completes 

		 ]]></description>
<return><![CDATA[An observable sequence of Array that will contain the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='windowWithCount' fullname='raix.reactive:AbsObservable/windowWithCount' isStatic='false' isFinal='false' isOverride='false'  param_names='count;skip' param_types='uint;uint' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[count The number of values to buffer

		 ]]></param>
<param><![CDATA[skip The number of values to offset after the buffer is emitted.

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='windowWithTimeOrCount' fullname='raix.reactive:AbsObservable/windowWithTimeOrCount' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;count;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first

		 ]]></description>
<param><![CDATA[timeMs The maximum amount of time for a child-sequence to capture values

		 ]]></param>
<param><![CDATA[count The maximum amount of values for a child-sequence to capture

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='windowWithTime' fullname='raix.reactive:AbsObservable/windowWithTime' isStatic='false' isFinal='false' isOverride='false'  param_names='timeMs;timeShiftMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Emits the values from a source sequence in groups of a specific size  

		 ]]></description>
<param><![CDATA[timeMs The amount of time to buffer before the values are released

		 ]]></param>
<param><![CDATA[timeShiftMs The amount of time to offset after the buffer is emitted

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of observable sequences with the same type as the current sequence

		 ]]></return>
</method>
<method name='window' fullname='raix.reactive:AbsObservable/window' isStatic='false' isFinal='false' isOverride='false'  param_names='windowClosingSelector' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Splits values into child-observable windows which are closed by the caller

		 ]]></description>
<param><![CDATA[windowClosingSelector Returns an IObservable that will emit a value or complete to indicate that the active 

		 		  window has closed. Called on subscription and immediately after each window closes. 

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the current sequence

		 ]]></return>
</method>
<method name='zip' fullname='raix.reactive:AbsObservable/zip' isStatic='false' isFinal='false' isOverride='false'  param_names='rightSource;selector' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Merges two sequences through a mapping function while only ever using each value once 

		 ]]></description>
<param><![CDATA[rightSource The sequence to combine with the current

		 ]]></param>
<param><![CDATA[selector The function to be executed when values are received from both sequences. The return value will be included in the output

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<classRec name='GroupedObservable' fullname='raix.reactive:GroupedObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\GroupedObservable.as' namespace='raix.reactive' access='internal' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive:IGroupedObservable' isFinal='false' isDynamic='false' >
</classRec>
<method name='GroupedObservable' fullname='raix.reactive:GroupedObservable/GroupedObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='key;underlyingObservable' param_types='Object;raix.reactive:IObservable' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='subscribeWith' fullname='raix.reactive:GroupedObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
</method>
<method name='key' fullname='raix.reactive:GroupedObservable/key/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
</method>
<field name='_key' fullname='raix.reactive:GroupedObservable/private:_key' type='Object' isStatic='false' isConst='false' >
</field>
<field name='_underlyingObservable' fullname='raix.reactive:GroupedObservable/private:_underlyingObservable' type='raix.reactive:IObservable' isStatic='false' isConst='false' >
</field>
<classRec name='ClosureObservable' fullname='raix.reactive:ClosureObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\ClosureObservable.as' namespace='raix.reactive' access='internal' baseclass='raix.reactive:AbsObservable' isFinal='false' isDynamic='false' >
</classRec>
<method name='ClosureObservable' fullname='raix.reactive:ClosureObservable/ClosureObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='observeFunc' param_types='Function' param_defaults='undefined' result_type='*'>
</method>
<method name='subscribeWith' fullname='raix.reactive:ClosureObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
</method>
<field name='_observeFunc' fullname='raix.reactive:ClosureObservable/private:_observeFunc' type='Function' isStatic='false' isConst='false' >
</field>
<classRec name='Subject' fullname='raix.reactive:Subject' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Subject.as' namespace='raix.reactive' access='public' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive:ISubject' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A Subject is both an IObservable and an IObserver, so it can be 

	 returned as an IObservable and fed values through the IObserver 

	 methods.

	 

	 <p>When returning a Subject as an IObservable, it's recommended that you

	 return subject.asObservable() to hide the original instance</p>

	 ]]></description>
</classRec>
<method name='Subject' fullname='raix.reactive:Subject/Subject' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='onCompleted' fullname='raix.reactive:Subject/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has completed and 

		 that no more messages will be received

		 ]]></description>
</method>
<method name='onError' fullname='raix.reactive:Subject/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has halted with an error 

		 and that no more messages will be received

		 ]]></description>
</method>
<method name='onNext' fullname='raix.reactive:Subject/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='pl' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that a value has been received

		 ]]></description>
</method>
<method name='subscribeWith' fullname='raix.reactive:Subject/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<method name='hasSubscriptions' fullname='raix.reactive:Subject/hasSubscriptions/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
<description><![CDATA[

		 Determines whether this subject has any subscriptions

		 ]]></description>
</method>
<method name='subscriptionCount' fullname='raix.reactive:Subject/subscriptionCount/get' isStatic='false' isFinal='false' isOverride='false'  result_type='int'>
<description><![CDATA[

		 Gets the number of subscriptions this subject has

		 ]]></description>
</method>
<field name='_isFinished' fullname='raix.reactive:Subject/private:_isFinished' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_observers' fullname='raix.reactive:Subject/private:_observers' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_subscriptionCount' fullname='raix.reactive:Subject/private:_subscriptionCount' type='uint' isStatic='false' isConst='false' defaultValue='0' >
</field>
<classRec name='Observable' fullname='raix.reactive:Observable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\Observable.as' namespace='raix.reactive' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Provides static methods that create IObservable sequences

	 ]]></description>
</classRec>
<method name='Observable' fullname='raix.reactive:Observable/Observable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='amb' fullname='raix.reactive:Observable/amb' isStatic='true' isFinal='false' isOverride='false'  param_names='sources' param_types='Array' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Takes multiple source sequences and returns values from the first sequence to emit a value  

		 ]]></description>
<param><![CDATA[sources The sources that will be subscribed to

		 ]]></param>
<return><![CDATA[An observable sequence of the same valueClass as the first sequence in sources

		 ]]></return>
</method>
<method name='catchErrors' fullname='raix.reactive:Observable/catchErrors' isStatic='true' isFinal='false' isOverride='false'  param_names='sources;scheduler' param_types='Array;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Concatonates a list of sequences as each one errors. A successful sequence ends the concatonation.  

		 ]]></description>
<param><![CDATA[sources The list of sequence to concatonate.

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence with the valueClass of the first sequence in sources

		 ]]></return>
</method>
<method name='concat' fullname='raix.reactive:Observable/concat' isStatic='true' isFinal='false' isOverride='false'  param_names='sources' param_types='*' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Concatonates multiple sequences by running each sequence as the previous one finishes 

		 ]]></description>
<param><![CDATA[sources Anything that can be converted to an IObservable of IObservables using toObservable

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='createWithCancelable' fullname='raix.reactive:Observable/createWithCancelable' isStatic='true' isFinal='false' isOverride='false'  param_names='subscribeFunc' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a custom observable sequence that uses cancelable resources  

		 ]]></description>
<param><![CDATA[subscribeFunc The function that will be executed when a subscriber subscribes, the return value of which is an ICancelable to be canceled when the sequence is terminated

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='create' fullname='raix.reactive:Observable/create' isStatic='true' isFinal='false' isOverride='false'  param_names='subscribeFunc' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a custom observable sequence  

		 ]]></description>
<param><![CDATA[subscribeFunc The function that will be executed when a subscriber subscribes, the return value of which is a function to be run when the sequence is terminated

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='defer' fullname='raix.reactive:Observable/defer' isStatic='true' isFinal='false' isOverride='false'  param_names='observableFactory' param_types='Function' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Defers selection of a sequence until the sequence is subscribed to  

		 ]]></description>
<param><![CDATA[observableFactory The function that will be executed when a new subscription occurs, the returned sequence will be used for the subscriber.

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='empty' fullname='raix.reactive:Observable/empty' isStatic='true' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence that immediately completes  

		 ]]></description>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='error' fullname='raix.reactive:Observable/error' isStatic='true' isFinal='false' isOverride='false'  param_names='err' param_types='Error' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence that immediately throws an Error  

		 ]]></description>
<param><![CDATA[error The error to raise when a new subscription occurs

		 ]]></param>
<param><![CDATA[valueClass The Class of the returned sequence

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='forkJoin' fullname='raix.reactive:Observable/forkJoin' isStatic='true' isFinal='false' isOverride='false'  param_names='sources' param_types='Array' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Subscribes to multiple source sequence and emits the last values of each after all have completed 

		 ]]></description>
<param><![CDATA[sources The sequences to subscribe to

		 ]]></param>
<return><![CDATA[An observable sequence of Array

		 ]]></return>
</method>
<method name='fromArray' fullname='raix.reactive:Observable/fromArray' isStatic='true' isFinal='false' isOverride='false'  param_names='values;scheduler' param_types='Array;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence consisting of the values in an Array 

		 ]]></description>
<param><![CDATA[values The array of values to iterate through

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of elementClass

		 ]]></return>
</method>
<method name='fromErrorEvents' fullname='raix.reactive:Observable/fromErrorEvents' isStatic='true' isFinal='false' isOverride='false'  param_names='eventDispatcher;eventTypes;useCapture;priority;errorMap' param_types='flash.events:IEventDispatcher;Array;Boolean;int;Function' param_defaults='undefined;undefined;false;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence that emits an error when one of several event valueClasss is received from an IEventDispatcher

		 ]]></description>
<param><![CDATA[eventDispatcher The IEventDispatcher that dispatches the event

		 ]]></param>
<param><![CDATA[eventTypes The event types that signify an error

		 ]]></param>
<param><![CDATA[useCapture Whether to pass useCapture when subscribing to and unsubscribing from the event

		 ]]></param>
<param><![CDATA[priority The priority of the event

		 ]]></param>
<param><![CDATA[errorMap The function that maps an event to an Error. null can be used if the event will be ErrorEvent

		 ]]></param>
<return><![CDATA[An observable sequence of 

		 ]]></return>
</method>
<method name='fromErrorEvent' fullname='raix.reactive:Observable/fromErrorEvent' isStatic='true' isFinal='false' isOverride='false'  param_names='eventDispatcher;eventType;useCapture;priority;errorMap' param_types='flash.events:IEventDispatcher;String;Boolean;int;Function' param_defaults='undefined;undefined;false;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence that emits an error when an event is received from an IEventDispatcher  

		 ]]></description>
<param><![CDATA[eventDispatcher The IEventDispatcher that dispatches the event

		 ]]></param>
<param><![CDATA[eventType The event type

		 ]]></param>
<param><![CDATA[useCapture Whether to pass useCapture when subscribing to and unsubscribing from the event

		 ]]></param>
<param><![CDATA[priority The priority of the event

		 ]]></param>
<param><![CDATA[errorMap The function that maps an event to an Error. null can be used if the event will be ErrorEvent

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass, or Object if valueClass is null 

		 ]]></return>
</method>
<method name='fromEvents' fullname='raix.reactive:Observable/fromEvents' isStatic='true' isFinal='false' isOverride='false'  param_names='eventDispatcher;eventTypes;useCapture;priority' param_types='flash.events:IEventDispatcher;Array;Boolean;int' param_defaults='undefined;undefined;false;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates Combines events from multiple event valueClasss 

		 ]]></description>
<param><![CDATA[eventDispatcher The IEventDispatcher that dispatches the event

		 ]]></param>
<param><![CDATA[eventTypes An array event type names

		 ]]></param>
<param><![CDATA[useCapture Whether to pass useCapture when subscribing to and unsubscribing from the event

		 ]]></param>
<param><![CDATA[priority The priority of the event

		 ]]></param>
<return><![CDATA[An observable sequence of commonValueClass, or Event if commonValueClass is null 

		 ]]></return>
</method>
<method name='fromEvent' fullname='raix.reactive:Observable/fromEvent' isStatic='true' isFinal='false' isOverride='false'  param_names='eventDispatcher;eventType;useCapture;priority' param_types='flash.events:IEventDispatcher;String;Boolean;int' param_defaults='undefined;undefined;false;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence of events from an IEventDispatcher 

		 ]]></description>
<param><![CDATA[eventDispatcher The IEventDispatcher that dispatches the event

		 ]]></param>
<param><![CDATA[eventType The valueClass of event dispatched by eventDispatcher. Event will be used if this argument is null.

		 ]]></param>
<param><![CDATA[useCapture Whether to pass useCapture when subscribing to and unsubscribing from the event

		 ]]></param>
<param><![CDATA[priority The priority of the event

		 ]]></param>
<return><![CDATA[An observable sequence of eventType, or Event if eventType is null

		 ]]></return>
</method>
<method name='generate' fullname='raix.reactive:Observable/generate' isStatic='true' isFinal='false' isOverride='false'  param_names='initialState;predicate;iterate;resultMap;scheduler' param_types='Object;Function;Function;Function;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a custom observable sequence that is controlled by methods supplied as arguments 

		 ]]></description>
<param><![CDATA[initialState The initial state value to use (of class valueClass)

		 ]]></param>
<param><![CDATA[predicate The predicate to determine whether the sequence has completed

		 ]]></param>
<param><![CDATA[iterate The function executed between iterations

		 ]]></param>
<param><![CDATA[resultMap The function that maps the current state to an output value

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='getNativeUncaughtErrors' fullname='raix.reactive:Observable/private:getNativeUncaughtErrors' isStatic='true' isFinal='false' isOverride='false'  param_names='loaderInfo' param_types='flash.display:LoaderInfo' param_defaults='undefined' result_type='raix.reactive:IObservable'>
</method>
<method name='ifElse' fullname='raix.reactive:Observable/ifElse' isStatic='true' isFinal='false' isOverride='false'  param_names='predicate;ifTrue;ifFalse' param_types='Function;raix.reactive:IObservable;raix.reactive:IObservable' param_defaults='undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Defers selection of one of two sequences until the sequence is subscribed to

		 ]]></description>
<param><![CDATA[predicate The function to execute when a subscription occurs to determine which sequence to subscribe to

		 ]]></param>
<param><![CDATA[ifTrue The sequence to subscribe to if predicate returns true

		 ]]></param>
<param><![CDATA[ifFalse The sequence to subscribe to if predicate returns false

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='interval' fullname='raix.reactive:Observable/interval' isStatic='true' isFinal='false' isOverride='false'  param_names='intervalMs;scheduler' param_types='uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates an unending observable sequence of integers that are incremented at a regular interval 

		 ]]></description>
<param><![CDATA[intervalMs The interval, in milliseconds, to wait in between values

		 ]]></param>
<param><![CDATA[scheduler The scheduler used for timing

		 ]]></param>
<return><![CDATA[An observable sequence of int

		 ]]></return>
</method>
<method name='lookup' fullname='raix.reactive:Observable/lookup' isStatic='true' isFinal='false' isOverride='false'  param_names='keySelector;dictionary' param_types='Function;flash.utils:Dictionary' param_defaults='undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Defers selection of the sequence to use by using a function that returns a key into a dictionary of sequences 

		 ]]></description>
<param><![CDATA[keySelector The function that, at the moment of subscription, will return the key into dictionary

		 ]]></param>
<param><![CDATA[dictionary The dictionary of sequences

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='mapErrorEvents' fullname='raix.reactive:Observable/private:mapErrorEvents' isStatic='true' isFinal='false' isOverride='false'  param_names='source;errorMap' param_types='raix.reactive:IObservable;Function' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
</method>
<method name='merge' fullname='raix.reactive:Observable/merge' isStatic='true' isFinal='false' isOverride='false'  param_names='sources;concurrent' param_types='*;uint' param_defaults='undefined;0' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Emits the values from multiple sources in the order that they arrive 

		 ]]></description>
<param><![CDATA[source Either an array of IObservable or an IObservable of IObservables

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
<see><![CDATA[raix.reactive.toObservable

		 ]]></see>
</method>
<method name='never' fullname='raix.reactive:Observable/never' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Returns an IObservable that never completes

		 ]]></description>
</method>
<method name='onErrorResumeNext' fullname='raix.reactive:Observable/onErrorResumeNext' isStatic='true' isFinal='false' isOverride='false'  param_names='sources;scheduler' param_types='Array;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Concatonates a list of sequence as each one errors or complete 

		 ]]></description>
<param><![CDATA[sources The list of sequences to concatonate

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of the valueClass of the value sequence in sources

		 ]]></return>
</method>
<method name='range' fullname='raix.reactive:Observable/range' isStatic='true' isFinal='false' isOverride='false'  param_names='start;count;scheduler' param_types='int;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence of consecutive integers  

		 ]]></description>
<param><![CDATA[start The inclusive start value of the range

		 ]]></param>
<param><![CDATA[count The number of values, including start, to emit

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of int

		 ]]></return>
</method>
<method name='repeatValue' fullname='raix.reactive:Observable/repeatValue' isStatic='true' isFinal='false' isOverride='false'  param_names='val;repeatCount;scheduler' param_types='Object;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;0;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Repeats a value a specification number of times 

		 ]]></description>
<param><![CDATA[value The value to repeat

		 ]]></param>
<param><![CDATA[repeatCount The number of times to emit the value

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='start' fullname='raix.reactive:Observable/start' isStatic='true' isFinal='false' isOverride='false'  param_names='action;scheduler' param_types='Function;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence based on a call to a function  

		 ]]></description>
<param><![CDATA[action The function to call

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='timer' fullname='raix.reactive:Observable/timer' isStatic='true' isFinal='false' isOverride='false'  param_names='delayMs;intervalMs;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates an unending observable sequence of integers that begin after a delay and are incremented at a regular interval 

		 ]]></description>
<param><![CDATA[delayMs The interval, in milliseconds, to wait before the first value

		 ]]></param>
<param><![CDATA[intervalMs The interval, in milliseconds, to wait in between subsequent values

		 ]]></param>
<param><![CDATA[scheduler The scheduler used for timing

		 ]]></param>
<return><![CDATA[An observable sequence of int

		 ]]></return>
</method>
<method name='toAsync' fullname='raix.reactive:Observable/toAsync' isStatic='true' isFinal='false' isOverride='false'  param_names='action;scheduler' param_types='Function;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='Function'>
<description><![CDATA[

		 Converts a function into an observable sequence  

		 ]]></description>
<param><![CDATA[action The function to call

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use

		 ]]></param>
<return><![CDATA[A function accepting the arguments of the original action, but that will 

		 return an IObservable when called.

		 ]]></return>
</method>
<method name='uncaughtErrors' fullname='raix.reactive:Observable/uncaughtErrors' isStatic='true' isFinal='false' isOverride='false'  param_names='loaderInfo' param_types='flash.display:LoaderInfo' param_defaults='null' result_type='raix.reactive:IObservable'>
</method>
<method name='urlLoaderInternal' fullname='raix.reactive:Observable/private:urlLoaderInternal' isStatic='true' isFinal='false' isOverride='false'  param_names='request;dataFormat;loaderContext' param_types='flash.net:URLRequest;String;flash.system:LoaderContext' param_defaults='undefined;text;null' result_type='raix.reactive:IObservable'>
</method>
<method name='urlLoader' fullname='raix.reactive:Observable/urlLoader' isStatic='true' isFinal='false' isOverride='false'  param_names='request;dataFormat;loaderContext' param_types='flash.net:URLRequest;String;flash.system:LoaderContext' param_defaults='undefined;text;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates an observable sequence that loads an object from a URLRequest 

		 ]]></description>
<param><![CDATA[request The URLRequest to load

		 ]]></param>
<param><![CDATA[dataFormat A value of flash.net.URLLoaderDataFormat

		 ]]></param>
<param><![CDATA[loaderContext The optional LoaderContext to use

		 ]]></param>
<return><![CDATA[An observable sequence of Object

		 ]]></return>
</method>
<method name='value' fullname='raix.reactive:Observable/value' isStatic='true' isFinal='false' isOverride='false'  param_names='val;scheduler' param_types='Object;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Create a sequence consisting of exactly one value 

		 ]]></description>
<param><![CDATA[value The value to emit

		 ]]></param>
<param><![CDATA[scheduler The scheduler to use to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='when' fullname='raix.reactive:Observable/when' isStatic='true' isFinal='false' isOverride='false'  param_names='plans' param_types='Array' param_defaults='undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Matches multiple plans (source sequence combinations) in the order they are specified 

		 ]]></description>
<param><![CDATA[plans The array of rx.Plan objects creates using 'and' and 'then'

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='xml' fullname='raix.reactive:Observable/xml' isStatic='true' isFinal='false' isOverride='false'  param_names='request;loaderContext' param_types='flash.net:URLRequest;flash.system:LoaderContext' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Loads an XML document

		 ]]></description>
<param><![CDATA[request The URLRequest to load

		 ]]></param>
<param><![CDATA[ignoreWhite Whether to ignore whitespace when parsing the XML

		 ]]></param>
<param><![CDATA[loaderContext The optional LoaderContext to use

		 ]]></param>
<return><![CDATA[An IObservable sequence of XMLDocument 

		 ]]></return>
</method>
<method name='maxConcurrentLoaders' fullname='raix.reactive:Observable/maxConcurrentLoaders/get' isStatic='true' isFinal='false' isOverride='false'  result_type='uint'>
<description><![CDATA[

		 Gets the maximum number of urlLoaders that can execute concurrently. The value 

		 defaults to 2 to prevent issues in some browers. 

		 ]]></description>
</method>
<method name='maxConcurrentLoaders' fullname='raix.reactive:Observable/maxConcurrentLoaders/set' isStatic='true' isFinal='false' isOverride='false'  param_names='value' param_types='uint' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Sets the maximum number of urlLoaders that can execute concurrently. Use 0 for 

		 no limit.

		 ]]></description>
</method>
<field name='_loaderQueueSubscription' fullname='raix.reactive:Observable/private:_loaderQueueSubscription' type='raix.reactive:ICancelable' isStatic='true' isConst='false' >
</field>
<field name='_loaderQueue' fullname='raix.reactive:Observable/private:_loaderQueue' type='raix.reactive:ISubject' isStatic='true' isConst='false' >
</field>
<field name='_maxConcurrentLoaders' fullname='raix.reactive:Observable/private:_maxConcurrentLoaders' type='int' isStatic='true' isConst='false' defaultValue='2' >
</field>
<field name='_unhandledErrorsSubject' fullname='raix.reactive:Observable/private:_unhandledErrorsSubject' type='raix.reactive:Subject' isStatic='true' isConst='false' defaultValue='unknown' >
</field>
<classRec name='Subscription' fullname='raix.reactive.testing:Subscription' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\Subscription.as' namespace='raix.reactive.testing' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='Subscription' fullname='raix.reactive.testing:Subscription/Subscription' isStatic='false' isFinal='false' isOverride='false'  param_names='subscribe;unsubscribe' param_types='Number;Number' param_defaults='undefined;unknown' result_type='*'>
</method>
<field name='subscribe' fullname='raix.reactive.testing:Subscription/subscribe' type='Number' isStatic='false' isConst='false' >
</field>
<field name='unsubscribe' fullname='raix.reactive.testing:Subscription/unsubscribe' type='Number' isStatic='false' isConst='false' >
</field>
<classRec name='Recorded' fullname='raix.reactive.testing:Recorded' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\Recorded.as' namespace='raix.reactive.testing' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='Recorded' fullname='raix.reactive.testing:Recorded/Recorded' isStatic='false' isFinal='false' isOverride='false'  param_names='time;notification' param_types='Number;raix.reactive:Notification' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='time' fullname='raix.reactive.testing:Recorded/time/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Number'>
</method>
<method name='value' fullname='raix.reactive.testing:Recorded/value/get' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:Notification'>
</method>
<field name='_notification' fullname='raix.reactive.testing:Recorded/private:_notification' type='raix.reactive:Notification' isStatic='false' isConst='false' >
</field>
<field name='_time' fullname='raix.reactive.testing:Recorded/private:_time' type='Number' isStatic='false' isConst='false' >
</field>
<classRec name='TestScheduler' fullname='raix.reactive.testing:TestScheduler' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\TestScheduler.as' namespace='raix.reactive.testing' access='public' baseclass='Object' interfaces='raix.reactive.scheduling:IScheduler' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 

	 ]]></description>
</classRec>
<method name='TestScheduler' fullname='raix.reactive.testing:TestScheduler/TestScheduler' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='createColdObservable' fullname='raix.reactive.testing:TestScheduler/createColdObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='recordedNotifications' param_types='Array' param_defaults='undefined' result_type='raix.reactive.testing:ColdObservable'>
<description><![CDATA[

		 Creates a sequence from "recorded" values that will start a new timeline for each susbcriber  

		 ]]></description>
<param><![CDATA[recordedNotifications An array of Recorded instances

		 ]]></param>
<return><![CDATA[An observable sequence that will start a new timeline for each susbcriber

		 ]]></return>
</method>
<method name='createHotObservable' fullname='raix.reactive.testing:TestScheduler/createHotObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='recordedNotifications' param_types='Array' param_defaults='undefined' result_type='raix.reactive.testing:HotObservable'>
<description><![CDATA[

		 Creates a sequence from "recorded" values that will share a timeline between all subscribers  

		 ]]></description>
<param><![CDATA[recordedNotifications An array of Recorded instances

		 ]]></param>
<return><![CDATA[An observable sequence that will share a timeline between all subscribers

		 ]]></return>
</method>
<method name='runTo' fullname='raix.reactive.testing:TestScheduler/runTo' isStatic='false' isFinal='false' isOverride='false'  param_names='time' param_types='Number' param_defaults='undefined' result_type='void'>
</method>
<method name='run' fullname='raix.reactive.testing:TestScheduler/run' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='schedule' fullname='raix.reactive.testing:TestScheduler/schedule' isStatic='false' isFinal='false' isOverride='false'  param_names='action;dueTime' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:ICancelable'>
</method>
<method name='actionCount' fullname='raix.reactive.testing:TestScheduler/actionCount/get' isStatic='false' isFinal='false' isOverride='false'  result_type='uint'>
</method>
<method name='now' fullname='raix.reactive.testing:TestScheduler/now/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Date'>
</method>
<field name='_now' fullname='raix.reactive.testing:TestScheduler/private:_now' type='Number' isStatic='false' isConst='false' defaultValue='0' >
</field>
<field name='_scheduledActions' fullname='raix.reactive.testing:TestScheduler/private:_scheduledActions' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<classRec name='MockObserver' fullname='raix.reactive.testing:MockObserver' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\MockObserver.as' namespace='raix.reactive.testing' access='public' baseclass='Object' interfaces='raix.reactive:IObserver' isFinal='false' isDynamic='false' >
</classRec>
<method name='MockObserver' fullname='raix.reactive.testing:MockObserver/MockObserver' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.testing:TestScheduler' param_defaults='undefined' result_type='*'>
</method>
<method name='assertNotifications' fullname='raix.reactive.testing:MockObserver/assertNotifications' isStatic='false' isFinal='false' isOverride='false'  param_names='expectedNotifications;failFunction;valueComparer;message' param_types='Array;Function;Function;String' param_defaults='undefined;undefined;null;null' result_type='void'>
</method>
<method name='assertTimings' fullname='raix.reactive.testing:MockObserver/assertTimings' isStatic='false' isFinal='false' isOverride='false'  param_names='recordedNotifications;failFunction;valueComparer;message' param_types='Array;Function;Function;String' param_defaults='undefined;undefined;null;null' result_type='void'>
</method>
<method name='assertValues' fullname='raix.reactive.testing:MockObserver/assertValues' isStatic='false' isFinal='false' isOverride='false'  param_names='expectedValues;failFunction;comparer;message' param_types='Array;Function;Function;String' param_defaults='undefined;undefined;null;null' result_type='void'>
</method>
<method name='completed' fullname='raix.reactive.testing:MockObserver/completed' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
</method>
<method name='defaultComparer' fullname='raix.reactive.testing:MockObserver/private:defaultComparer' isStatic='false' isFinal='false' isOverride='false'  param_names='x;y' param_types='Object;Object' param_defaults='undefined;undefined' result_type='Boolean'>
</method>
<method name='error' fullname='raix.reactive.testing:MockObserver/error' isStatic='false' isFinal='false' isOverride='false'  result_type='Error'>
</method>
<method name='formatNotification' fullname='raix.reactive.testing:MockObserver/private:formatNotification' isStatic='false' isFinal='false' isOverride='false'  param_names='notification' param_types='raix.reactive:Notification' param_defaults='undefined' result_type='String'>
</method>
<method name='hasError' fullname='raix.reactive.testing:MockObserver/hasError' isStatic='false' isFinal='false' isOverride='false'  result_type='Boolean'>
</method>
<method name='notificationEquals' fullname='raix.reactive.testing:MockObserver/private:notificationEquals' isStatic='false' isFinal='false' isOverride='false'  param_names='expected;actual;valueComparer' param_types='raix.reactive:Notification;raix.reactive:Notification;Function' param_defaults='undefined;undefined;undefined' result_type='Boolean'>
</method>
<method name='onCompleted' fullname='raix.reactive.testing:MockObserver/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has completed and 

		 that no more messages will be received

		 ]]></description>
</method>
<method name='onError' fullname='raix.reactive.testing:MockObserver/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='error' param_types='Error' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has halted with an error 

		 and that no more messages will be received

		 ]]></description>
</method>
<method name='onNext' fullname='raix.reactive.testing:MockObserver/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that a value has been received

		 ]]></description>
</method>
<method name='recordedNotifications' fullname='raix.reactive.testing:MockObserver/recordedNotifications/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
</method>
<field name='_completed' fullname='raix.reactive.testing:MockObserver/private:_completed' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_error' fullname='raix.reactive.testing:MockObserver/private:_error' type='Error' isStatic='false' isConst='false' defaultValue='null' >
</field>
<field name='_recordedNotificatons' fullname='raix.reactive.testing:MockObserver/private:_recordedNotificatons' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_scheduler' fullname='raix.reactive.testing:MockObserver/private:_scheduler' type='raix.reactive.testing:TestScheduler' isStatic='false' isConst='false' >
</field>
<field name='_values' fullname='raix.reactive.testing:MockObserver/private:_values' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<classRec name='ColdObservable' fullname='raix.reactive.testing:ColdObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\ColdObservable.as' namespace='raix.reactive.testing' access='public' baseclass='raix.reactive:AbsObservable' isFinal='false' isDynamic='false' >
</classRec>
<method name='ColdObservable' fullname='raix.reactive.testing:ColdObservable/ColdObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler;messages' param_types='raix.reactive.testing:TestScheduler;Array' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='subscribeWith' fullname='raix.reactive.testing:ColdObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
</method>
<method name='subscriptions' fullname='raix.reactive.testing:ColdObservable/subscriptions/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
</method>
<field name='_messages' fullname='raix.reactive.testing:ColdObservable/private:_messages' type='Array' isStatic='false' isConst='false' >
</field>
<field name='_scheduler' fullname='raix.reactive.testing:ColdObservable/private:_scheduler' type='raix.reactive.testing:TestScheduler' isStatic='false' isConst='false' >
</field>
<field name='_subscriptions' fullname='raix.reactive.testing:ColdObservable/private:_subscriptions' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<classRec name='HotObservable' fullname='raix.reactive.testing:HotObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\testing\HotObservable.as' namespace='raix.reactive.testing' access='public' baseclass='raix.reactive:AbsObservable' isFinal='false' isDynamic='false' >
</classRec>
<method name='HotObservable' fullname='raix.reactive.testing:HotObservable/HotObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler;messages' param_types='raix.reactive.testing:TestScheduler;Array' param_defaults='undefined;undefined' result_type='*'>
</method>
<method name='subscribeWith' fullname='raix.reactive.testing:HotObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
</method>
<method name='observers' fullname='raix.reactive.testing:HotObservable/observers/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
</method>
<method name='subscriptions' fullname='raix.reactive.testing:HotObservable/subscriptions/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Array'>
</method>
<field name='_messages' fullname='raix.reactive.testing:HotObservable/private:_messages' type='Array' isStatic='false' isConst='false' >
</field>
<field name='_observers' fullname='raix.reactive.testing:HotObservable/private:_observers' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_scheduler' fullname='raix.reactive.testing:HotObservable/private:_scheduler' type='raix.reactive.testing:TestScheduler' isStatic='false' isConst='false' >
</field>
<field name='_subscriptions' fullname='raix.reactive.testing:HotObservable/private:_subscriptions' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<interfaceRec name='IScheduler' fullname='raix.reactive.scheduling:IScheduler' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\scheduling\IScheduler.as' namespace='raix.reactive.scheduling' access='public' baseClasses='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Used to distribute workload

	 ]]></description>
</interfaceRec>
<method name='schedule' fullname='raix.reactive.scheduling:IScheduler/raix.reactive.scheduling:IScheduler:schedule' isStatic='false' isFinal='false' isOverride='false'  param_names='action;dueTime' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Schedules a function to be run, either immediately or in the future 

		 ]]></description>
<param><![CDATA[action The function to run

		 ]]></param>
<param><![CDATA[dueTime The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity

		 ]]></param>
<return><![CDATA[An ICancelable that will stop the action from being run, if it hasn't already

		 ]]></return>
</method>
<method name='now' fullname='raix.reactive.scheduling:IScheduler/raix.reactive.scheduling:IScheduler:now/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Date'>
<description><![CDATA[

		 Gets the current Date and time

		 ]]></description>
</method>
<classRec name='TimerPool' fullname='raix.reactive.scheduling:TimerPool' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\scheduling\TimerPool.as' namespace='raix.reactive.scheduling' access='internal' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='TimerPool' fullname='raix.reactive.scheduling:TimerPool/TimerPool' isStatic='false' isFinal='false' isOverride='false'  param_names='capacity' param_types='int' param_defaults='undefined' result_type='*'>
</method>
<method name='obtain' fullname='raix.reactive.scheduling:TimerPool/obtain' isStatic='false' isFinal='false' isOverride='false'  result_type='flash.utils:Timer'>
</method>
<method name='release' fullname='raix.reactive.scheduling:TimerPool/release' isStatic='false' isFinal='false' isOverride='false'  param_names='timer' param_types='flash.utils:Timer' param_defaults='undefined' result_type='void'>
</method>
<method name='instance' fullname='raix.reactive.scheduling:TimerPool/instance/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:TimerPool'>
</method>
<method name='size' fullname='raix.reactive.scheduling:TimerPool/size/get' isStatic='false' isFinal='false' isOverride='false'  result_type='int'>
</method>
<field name='DEFAULT_CAPACITY' fullname='raix.reactive.scheduling:TimerPool/private:DEFAULT_CAPACITY' type='int' isStatic='true' isConst='true' defaultValue='10' >
</field>
<field name='_capacity' fullname='raix.reactive.scheduling:TimerPool/private:_capacity' type='int' isStatic='false' isConst='false' >
</field>
<field name='_createCount' fullname='raix.reactive.scheduling:TimerPool/private:_createCount' type='int' isStatic='false' isConst='false' defaultValue='0' >
</field>
<field name='_instance' fullname='raix.reactive.scheduling:TimerPool/private:_instance' type='raix.reactive.scheduling:TimerPool' isStatic='true' isConst='false' defaultValue='unknown' >
</field>
<field name='_maxCreated' fullname='raix.reactive.scheduling:TimerPool/private:_maxCreated' type='int' isStatic='false' isConst='false' defaultValue='0' >
</field>
<field name='_pool' fullname='raix.reactive.scheduling:TimerPool/private:_pool' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<classRec name='ImmediateScheduler' fullname='raix.reactive.scheduling:ImmediateScheduler' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\scheduling\ImmediateScheduler.as' namespace='raix.reactive.scheduling' access='public' baseclass='Object' interfaces='raix.reactive.scheduling:IScheduler' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A scheduler that executes actions immediately, or immediately

	 after their dueTime (if specified).

	 ]]></description>
</classRec>
<method name='schedule' fullname='raix.reactive.scheduling:ImmediateScheduler/schedule' isStatic='false' isFinal='false' isOverride='false'  param_names='action;dueTime' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Schedules a function to be run, either immediately or in the future 

		 ]]></description>
<param><![CDATA[action The function to run

		 ]]></param>
<param><![CDATA[dueTime The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity

		 ]]></param>
<return><![CDATA[An ICancelable that will stop the action from being run, if it hasn't already

		 ]]></return>
</method>
<method name='instance' fullname='raix.reactive.scheduling:ImmediateScheduler/instance/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:ImmediateScheduler'>
<description><![CDATA[

		 Gets the singleton instance of this scheduler

		 ]]></description>
</method>
<method name='now' fullname='raix.reactive.scheduling:ImmediateScheduler/now/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Date'>
<description><![CDATA[

		 

		 Gets the current Date and time

		 ]]></description>
</method>
<field name='_instance' fullname='raix.reactive.scheduling:ImmediateScheduler/private:_instance' type='raix.reactive.scheduling:ImmediateScheduler' isStatic='true' isConst='false' defaultValue='unknown' >
</field>
<field name='_pendingActions' fullname='raix.reactive.scheduling:ImmediateScheduler/private:_pendingActions' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_runningAction' fullname='raix.reactive.scheduling:ImmediateScheduler/private:_runningAction' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<classRec name='Scheduler' fullname='raix.reactive.scheduling:Scheduler' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\scheduling\Scheduler.as' namespace='raix.reactive.scheduling' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Provides static helpers to schedulers

	 ]]></description>
</classRec>
<method name='scheduleRecursive' fullname='raix.reactive.scheduling:Scheduler/scheduleRecursive' isStatic='true' isFinal='false' isOverride='false'  param_names='scheduler;action;dueTime' param_types='raix.reactive.scheduling:IScheduler;Function;int' param_defaults='undefined;undefined;0' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Schedules a recursive action on an IScheduler 

		 ]]></description>
<param><![CDATA[scheduler The scheduler that will schedule each recursive call

		 ]]></param>
<param><![CDATA[action The action to call. The action will be called with one argument: a Function that call be called to reschedule the original action

		 ]]></param>
<param><![CDATA[dueTime The amount of time to delay the call to ation

		 ]]></param>
<return><![CDATA[An ICancelable that can be used to cancel the recursive schedule at any time

		 ]]></return>
</method>
<method name='asynchronous' fullname='raix.reactive.scheduling:Scheduler/asynchronous/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:IScheduler'>
<description><![CDATA[

		 Gets the default asynchronous scheduler

		 ]]></description>
</method>
<method name='defaultScheduler' fullname='raix.reactive.scheduling:Scheduler/defaultScheduler/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:IScheduler'>
<description><![CDATA[

		 Gets the default scheduler

		 ]]></description>
</method>
<method name='greenThread' fullname='raix.reactive.scheduling:Scheduler/greenThread/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:GreenThreadScheduler'>
<description><![CDATA[

		 Gets the GreenThreadScheduler singleton instance

		 ]]></description>
</method>
<method name='immediate' fullname='raix.reactive.scheduling:Scheduler/immediate/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:ImmediateScheduler'>
<description><![CDATA[

		 Gets the ImmediateScheduler singleton instance

		 ]]></description>
</method>
<method name='synchronous' fullname='raix.reactive.scheduling:Scheduler/synchronous/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:IScheduler'>
<description><![CDATA[

		 Gets the default synchronous scheduler

		 ]]></description>
</method>
<classRec name='GreenThreadScheduler' fullname='raix.reactive.scheduling:GreenThreadScheduler' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\scheduling\GreenThreadScheduler.as' namespace='raix.reactive.scheduling' access='public' baseclass='Object' interfaces='raix.reactive.scheduling:IScheduler' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A scheduler that distributes work on a timer, limiting the total execution 

	 time per 'switch' to maintain a framerate

	 

	 <p>Adding more work results in the work taking longer to complete, but the 

	 framerate remaining constant</p>

	 

	 <p>To benefit from GreenThreadScheduler, scheduled actions should execute in 

	 this smallest possible time (ie. be designed to be run many times</p>

	 ]]></description>
</classRec>
<method name='GreenThreadScheduler' fullname='raix.reactive.scheduling:GreenThreadScheduler/GreenThreadScheduler' isStatic='false' isFinal='false' isOverride='false'  param_names='contextSwitchObservable' param_types='raix.reactive:IObservable' param_defaults='undefined' result_type='*'>
</method>
<method name='executeGreenThread' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:executeGreenThread' isStatic='false' isFinal='false' isOverride='false'  param_names='args' param_types='restParam' param_defaults='undefined' result_type='void'>
</method>
<method name='schedule' fullname='raix.reactive.scheduling:GreenThreadScheduler/schedule' isStatic='false' isFinal='false' isOverride='false'  param_names='action;dueTime' param_types='Function;int' param_defaults='undefined;0' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Schedules a function to be run, either immediately or in the future 

		 ]]></description>
<param><![CDATA[action The function to run

		 ]]></param>
<param><![CDATA[dueTime The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity

		 ]]></param>
<return><![CDATA[An ICancelable that will stop the action from being run, if it hasn't already

		 ]]></return>
</method>
<method name='stopSwitching' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:stopSwitching' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='contextSwitchTime' fullname='raix.reactive.scheduling:GreenThreadScheduler/contextSwitchTime/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Number'>
<description><![CDATA[

		 Gets or sets the amount of time, in milliseconds, to allocate to 

		 execution on every context 'switch' 

		 ]]></description>
</method>
<method name='instance' fullname='raix.reactive.scheduling:GreenThreadScheduler/instance/get' isStatic='true' isFinal='false' isOverride='false'  result_type='raix.reactive.scheduling:GreenThreadScheduler'>
<description><![CDATA[

		 Gets the singleton instance of this scheduler

		 ]]></description>
</method>
<method name='now' fullname='raix.reactive.scheduling:GreenThreadScheduler/now/get' isStatic='false' isFinal='false' isOverride='false'  result_type='Date'>
<description><![CDATA[

		 

		 Gets the current Date and time

		 ]]></description>
</method>
<method name='contextSwitchTime' fullname='raix.reactive.scheduling:GreenThreadScheduler/contextSwitchTime/set' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Number' param_defaults='undefined' result_type='void'>
</method>
<field name='_contextSwitchObservable' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_contextSwitchObservable' type='raix.reactive:IObservable' isStatic='false' isConst='false' >
</field>
<field name='_contextSwitchSubscription' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_contextSwitchSubscription' type='raix.reactive:ICancelable' isStatic='false' isConst='false' >
</field>
<field name='_contextSwitchTime' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_contextSwitchTime' type='Number' isStatic='false' isConst='false' defaultValue='100' >
</field>
<field name='_instance' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_instance' type='raix.reactive.scheduling:GreenThreadScheduler' isStatic='true' isConst='false' defaultValue='unknown' >
</field>
<field name='_pendingActions' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_pendingActions' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_runningAction' fullname='raix.reactive.scheduling:GreenThreadScheduler/private:_runningAction' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<interfaceRec name='IConnectableObservable' fullname='raix.reactive.subjects:IConnectableObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\subjects\IConnectableObservable.as' namespace='raix.reactive.subjects' access='public' baseClasses='raix.reactive:IObservable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Represents a 'pending' hot observable. Calling connect will turn the observable 

	 into a hot observable. Calling refCount will turn the observable into a hot observable 

	 when the first observer subscribes

	 ]]></description>
</interfaceRec>
<method name='connect' fullname='raix.reactive.subjects:IConnectableObservable/raix.reactive.subjects:IConnectableObservable:connect' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 Makes this observable 'hot', so that values will be 

		 emitted whether there is a subscriber connected or not.

		 ]]></description>
</method>
<method name='refCount' fullname='raix.reactive.subjects:IConnectableObservable/raix.reactive.subjects:IConnectableObservable:refCount' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Makes this observable 'hot' when an observer subscribes, and 

		 will cancel the source subscription when the last observer unsubscribes

		 ]]></description>
</method>
<classRec name='ReplaySubject' fullname='raix.reactive.subjects:ReplaySubject' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\subjects\ReplaySubject.as' namespace='raix.reactive.subjects' access='public' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive:ISubject' isFinal='false' isDynamic='false' >
</classRec>
<method name='ReplaySubject' fullname='raix.reactive.subjects:ReplaySubject/ReplaySubject' isStatic='false' isFinal='false' isOverride='false'  param_names='bufferSize;window;scheduler' param_types='uint;uint;raix.reactive.scheduling:IScheduler' param_defaults='0;0;null' result_type='*'>
</method>
<method name='addValue' fullname='raix.reactive.subjects:ReplaySubject/private:addValue' isStatic='false' isFinal='false' isOverride='false'  param_names='notification' param_types='raix.reactive:Notification' param_defaults='undefined' result_type='void'>
</method>
<method name='onCompleted' fullname='raix.reactive.subjects:ReplaySubject/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='onError' fullname='raix.reactive.subjects:ReplaySubject/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='err' param_types='Error' param_defaults='undefined' result_type='void'>
</method>
<method name='onNext' fullname='raix.reactive.subjects:ReplaySubject/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
</method>
<method name='removeInvalidValues' fullname='raix.reactive.subjects:ReplaySubject/private:removeInvalidValues' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='subscribeWith' fullname='raix.reactive.subjects:ReplaySubject/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
</method>
<field name='_bufferSize' fullname='raix.reactive.subjects:ReplaySubject/private:_bufferSize' type='uint' isStatic='false' isConst='false' >
</field>
<field name='_complete' fullname='raix.reactive.subjects:ReplaySubject/private:_complete' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_liveObservers' fullname='raix.reactive.subjects:ReplaySubject/private:_liveObservers' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_observerValues' fullname='raix.reactive.subjects:ReplaySubject/private:_observerValues' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_scheduler' fullname='raix.reactive.subjects:ReplaySubject/private:_scheduler' type='raix.reactive.scheduling:IScheduler' isStatic='false' isConst='false' >
</field>
<field name='_values' fullname='raix.reactive.subjects:ReplaySubject/private:_values' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_window' fullname='raix.reactive.subjects:ReplaySubject/private:_window' type='uint' isStatic='false' isConst='false' >
</field>
<classRec name='AsyncSubject' fullname='raix.reactive.subjects:AsyncSubject' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\subjects\AsyncSubject.as' namespace='raix.reactive.subjects' access='public' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive:ISubject' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 A subject that replays the last value (or error) received to observers that subscribe 

	 after the sequence has completed

	 ]]></description>
</classRec>
<method name='AsyncSubject' fullname='raix.reactive.subjects:AsyncSubject/AsyncSubject' isStatic='false' isFinal='false' isOverride='false'  param_names='scheduler' param_types='raix.reactive.scheduling:IScheduler' param_defaults='null' result_type='*'>
</method>
<method name='dispatchAll' fullname='raix.reactive.subjects:AsyncSubject/private:dispatchAll' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
</method>
<method name='dispatch' fullname='raix.reactive.subjects:AsyncSubject/private:dispatch' isStatic='false' isFinal='false' isOverride='false'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='void'>
</method>
<method name='lastValue' fullname='raix.reactive.subjects:AsyncSubject/lastValue' isStatic='false' isFinal='false' isOverride='false'  result_type='Object'>
<description><![CDATA[

		 Gets the last value received, or throws an IllegalOperationError if no value 

		 has been received.

		 ]]></description>
</method>
<method name='onCompleted' fullname='raix.reactive.subjects:AsyncSubject/onCompleted' isStatic='false' isFinal='false' isOverride='false'  result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has completed and 

		 that no more messages will be received

		 ]]></description>
</method>
<method name='onError' fullname='raix.reactive.subjects:AsyncSubject/onError' isStatic='false' isFinal='false' isOverride='false'  param_names='err' param_types='Error' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that the sequence has halted with an error 

		 and that no more messages will be received

		 ]]></description>
</method>
<method name='onNext' fullname='raix.reactive.subjects:AsyncSubject/onNext' isStatic='false' isFinal='false' isOverride='false'  param_names='value' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 

		 Notifies the subscriber that a value has been received

		 ]]></description>
</method>
<method name='subscribeWith' fullname='raix.reactive.subjects:AsyncSubject/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<field name='_complete' fullname='raix.reactive.subjects:AsyncSubject/private:_complete' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_lastValue' fullname='raix.reactive.subjects:AsyncSubject/private:_lastValue' type='raix.reactive:Notification' isStatic='false' isConst='false' >
</field>
<field name='_observers' fullname='raix.reactive.subjects:AsyncSubject/private:_observers' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_scheduler' fullname='raix.reactive.subjects:AsyncSubject/private:_scheduler' type='raix.reactive.scheduling:IScheduler' isStatic='false' isConst='false' >
</field>
<classRec name='ConnectableObservable' fullname='raix.reactive.subjects:ConnectableObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\subjects\ConnectableObservable.as' namespace='raix.reactive.subjects' access='public' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive.subjects:IConnectableObservable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Concrete implementation of IConnectableObservable

	 ]]></description>
</classRec>
<method name='ConnectableObservable' fullname='raix.reactive.subjects:ConnectableObservable/ConnectableObservable' isStatic='false' isFinal='false' isOverride='false'  param_names='source;subject' param_types='raix.reactive:IObservable;raix.reactive:ISubject' param_defaults='undefined;null' result_type='*'>
</method>
<method name='connect' fullname='raix.reactive.subjects:ConnectableObservable/connect' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Makes this observable 'hot', so that values will be 

		 emitted whether there is a subscriber connected or not.

		 ]]></description>
</method>
<method name='refCount' fullname='raix.reactive.subjects:ConnectableObservable/refCount' isStatic='false' isFinal='false' isOverride='false'  result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 

		 Makes this observable 'hot' when an observer subscribes, and 

		 will cancel the source subscription when the last observer unsubscribes

		 ]]></description>
</method>
<method name='subscribeWith' fullname='raix.reactive.subjects:ConnectableObservable/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<field name='_source' fullname='raix.reactive.subjects:ConnectableObservable/private:_source' type='raix.reactive:IObservable' isStatic='false' isConst='false' >
</field>
<field name='_subject' fullname='raix.reactive.subjects:ConnectableObservable/private:_subject' type='raix.reactive:ISubject' isStatic='false' isConst='false' >
</field>
<field name='_subscription' fullname='raix.reactive.subjects:ConnectableObservable/private:_subscription' type='raix.reactive:ICancelable' isStatic='false' isConst='false' >
</field>
<interfaceRec name='IObservableResponder' fullname='raix.reactive.flex:IObservableResponder' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\flex\IObservableResponder.as' namespace='raix.reactive.flex' access='public' baseClasses='mx.rpc:IResponder;raix.reactive:IObservable' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 An observable sequence that is also an mx.rpc.IResponse

	 ]]></description>
</interfaceRec>
<classRec name='FlexObservable' fullname='raix.reactive.flex:FlexObservable' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\flex\FlexObservable.as' namespace='raix.reactive.flex' access='public' baseclass='Object' isFinal='false' isDynamic='false' >
</classRec>
<method name='FlexObservable' fullname='raix.reactive.flex:FlexObservable/FlexObservable' isStatic='false' isFinal='false' isOverride='false'  result_type='*'>
</method>
<method name='fromAsyncPattern' fullname='raix.reactive.flex:FlexObservable/fromAsyncPattern' isStatic='true' isFinal='false' isOverride='false'  param_names='valueClass;asyncMethod;args' param_types='Class;Function;Array' param_defaults='undefined;undefined;undefined' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates an observable sequence from a function that returns an AsyncToken 

		 ]]></description>
<param><![CDATA[valueClass The class of the value returned by the AsyncToken

		 ]]></param>
<param><![CDATA[asyncMethod The method to execute when a new subscription occurs. This method must return AsyncToken

		 ]]></param>
<param><![CDATA[args The arguments to supply to asyncMethod

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<method name='fromCollection' fullname='raix.reactive.flex:FlexObservable/fromCollection' isStatic='true' isFinal='false' isOverride='false'  param_names='elementClass;collection;scheduler' param_types='Class;mx.collections:ICollectionView;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence consisting of the values in a collection 

		 ]]></description>
<param><![CDATA[elementClass The class common to all values in values

		 ]]></param>
<param><![CDATA[values The collection of values to iterate through

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of elementType

		 ]]></return>
</method>
<method name='fromList' fullname='raix.reactive.flex:FlexObservable/fromList' isStatic='true' isFinal='false' isOverride='false'  param_names='elementClass;list;scheduler' param_types='Class;mx.collections:IList;raix.reactive.scheduling:IScheduler' param_defaults='undefined;undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence consisting of the values in a list 

		 ]]></description>
<param><![CDATA[elementClass The class common to all values in values

		 ]]></param>
<param><![CDATA[values The list of values to iterate through

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of elementType

		 ]]></return>
</method>
<method name='fromViewCursor' fullname='raix.reactive.flex:FlexObservable/fromViewCursor' isStatic='true' isFinal='false' isOverride='false'  param_names='cursor;scheduler' param_types='mx.collections:IViewCursor;raix.reactive.scheduling:IScheduler' param_defaults='undefined;null' result_type='raix.reactive:IObservable'>
<description><![CDATA[

		 Creates a sequence consisting of the values in a view cursor 

		 ]]></description>
<param><![CDATA[elementClass The class common to all values in values

		 ]]></param>
<param><![CDATA[values The view cursor of values to iterate through

		 ]]></param>
<param><![CDATA[scheduler The scheduler used to control flow

		 ]]></param>
<return><![CDATA[An observable sequence of elementClass

		 ]]></return>
</method>
<method name='responder' fullname='raix.reactive.flex:FlexObservable/responder' isStatic='true' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='raix.reactive.flex:IObservableResponder'>
<description><![CDATA[

		 Creates an observable sequence that is also an IResponder 

		 ]]></description>
<param><![CDATA[valueClass The valueClass of the returned sequence

		 ]]></param>
<return><![CDATA[An observable sequence of valueClass

		 ]]></return>
</method>
<classRec name='ObservableResponder' fullname='raix.reactive.flex:ObservableResponder' sourcefile='C:\Users\richard.szalay\Code\raix\master\source\raix\src\raix\reactive\flex\ObservableResponder.as' namespace='raix.reactive.flex' access='public' baseclass='raix.reactive:AbsObservable' interfaces='raix.reactive.flex:IObservableResponder' isFinal='false' isDynamic='false' >
<description><![CDATA[

	 Concrete implementation of an observable sequence that is also an mx.rpc.IResponder

	 ]]></description>
</classRec>
<method name='ObservableResponder' fullname='raix.reactive.flex:ObservableResponder/ObservableResponder' isStatic='false' isFinal='false' isOverride='false'  param_names='valueClass' param_types='Class' param_defaults='undefined' result_type='*'>
</method>
<method name='fault' fullname='raix.reactive.flex:ObservableResponder/fault' isStatic='false' isFinal='false' isOverride='false'  param_names='info' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Implementation of mx.rpc.IResponder.fault()

		 ]]></description>
</method>
<method name='getFaultError' fullname='raix.reactive.flex:ObservableResponder/private:getFaultError' isStatic='false' isFinal='false' isOverride='false'  param_names='info' param_types='Object' param_defaults='undefined' result_type='Error'>
</method>
<method name='result' fullname='raix.reactive.flex:ObservableResponder/result' isStatic='false' isFinal='false' isOverride='false'  param_names='data' param_types='Object' param_defaults='undefined' result_type='void'>
<description><![CDATA[

		 Implementation of mx.rpc.IResponder.result()

		 ]]></description>
</method>
<method name='subscribeWith' fullname='raix.reactive.flex:ObservableResponder/subscribeWith' isStatic='false' isFinal='false' isOverride='true'  param_names='observer' param_types='raix.reactive:IObserver' param_defaults='undefined' result_type='raix.reactive:ICancelable'>
<description><![CDATA[

		 

		 Subscribes to this observable using the supplied observer

		 ]]></description>
<return><![CDATA[An instance of ICancelable that can be used to unsubscribe at anytime by calling <code>cancel()</code> 

		 ]]></return>
</method>
<field name='_isComplete' fullname='raix.reactive.flex:ObservableResponder/private:_isComplete' type='Boolean' isStatic='false' isConst='false' defaultValue='false' >
</field>
<field name='_observers' fullname='raix.reactive.flex:ObservableResponder/private:_observers' type='Array' isStatic='false' isConst='false' defaultValue='unknown' >
</field>
<field name='_valueClass' fullname='raix.reactive.flex:ObservableResponder/private:_valueClass' type='Class' isStatic='false' isConst='false' >
</field>
</asdoc>
