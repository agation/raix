<?xml version="1.0" encoding="UTF-8"?><apiPackage id="raix.reactive"><apiName>raix.reactive</apiName><apiDetail/><apiClassifier id="raix.reactive:MutableCancelable"><apiName>MutableCancelable</apiName><shortdesc>
	A cancelable resource than is not immediately available
	</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	A cancelable resource than is not immediately available
	</apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:MutableCancelable:MutableCancelable"><apiName>MutableCancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:MutableCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation for current and future innerCancelable values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation for current and future innerCancelable values
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:MutableCancelable:cancelable:set"><apiName>cancelable</apiName><shortdesc>
		 Assigns the cancelable operation.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>raix.reactive:ICancelable</apiValueClassifier></apiValueDef><apiDesc>
		 Assigns the cancelable operation.
		 
		 If an existing value exists for innerCancelable, it will be canceled.
		 
		 If cancel() has already been called on this FutureCancelable, the value 
		 will be instantly canceled and innerCancelable will be null
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Observer"><apiName>Observer</apiName><shortdesc>
	 Provides static methods that create observers
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create observers
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Observer:Observer"><apiName>Observer</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Observer:create"><apiName>create</apiName><shortdesc>
		 Creates an IObserver from onNext, onCompleted and onError functions
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>The function to call when a value is received
		 </apiDesc></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to call when the sequence has complted
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to call if an error occurs in the sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an IObserver from onNext, onCompleted and onError functions
		 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:TimeStamped"><apiName>TimeStamped</apiName><shortdesc>
	 A wrapper that adds a timestamp to a value
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A wrapper that adds a timestamp to a value
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeStamped:TimeStamped"><apiName>TimeStamped</apiName><shortdesc>
		 Creates a TimeStamped wrapper 
		 </shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value from the original sequence
		 </apiDesc></apiParam><apiParam><apiItemName>time</apiItemName><apiType value="Number"/><apiDesc>The timestamp value
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Creates a TimeStamped wrapper 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:TimeStamped:timestamp:get"><apiName>timestamp</apiName><shortdesc>
		 Gets the timestamp value 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
		 Gets the timestamp value 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:TimeStamped:value:get"><apiName>value</apiName><shortdesc>
		 Gets the original value 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the original value 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:TimeInterval"><apiName>TimeInterval</apiName><shortdesc>
	 A wrapper that adds the time interval, in milliseconds,
	 since the last values 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A wrapper that adds the time interval, in milliseconds,
	 since the last values 
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeInterval:TimeInterval"><apiName>TimeInterval</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam><apiParam><apiItemName>interval</apiItemName><apiType value="Number"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:TimeInterval:interval:get"><apiName>interval</apiName><shortdesc>
		 Gets the internal, in milliseconds, 
		 since the last value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
		 Gets the internal, in milliseconds, 
		 since the last value
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:TimeInterval:value:get"><apiName>value</apiName><shortdesc>
		 Gets the original value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the original value
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Unit"><apiName>Unit</apiName><shortdesc>
	 Represents a valueClass that can be used when 
	 an observable sequence logically has no valueClass
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a valueClass that can be used when 
	 an observable sequence logically has no valueClass
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Unit:Unit"><apiName>Unit</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="raix.reactive:BooleanCancelable"><apiName>BooleanCancelable</apiName><shortdesc>
	 Represents a cancelable operation, the canceled status of which can 
	 be checked by isCanceled 
	</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a cancelable operation, the canceled status of which can 
	 be checked by isCanceled 
	</apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:BooleanCancelable:BooleanCancelable"><apiName>BooleanCancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:BooleanCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation. isCanceled will return true after this call.
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:BooleanCancelable:isCanceled:get"><apiName>isCanceled</apiName><shortdesc>
		 Determines if canceled() has been called on this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determines if canceled() has been called on this instance
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:IGroupedObservable"><apiName>IGroupedObservable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef></apiClassifierDetail><apiValue id="raix.reactive:IGroupedObservable:raix.reactive:IGroupedObservable:key:get"><apiName>key</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:OnError"><apiName>OnError</apiName><shortdesc>
	 A Notification for an onError call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onError call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnError:OnError"><apiName>OnError</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnError:accept"><apiName>accept</apiName><shortdesc>
		 Calls onError if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onError if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnError:error:get"><apiName>error</apiName><shortdesc>
		 Gets the error for this message 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Gets the error for this message 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns false since no values are associated with errors 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns false since no values are associated with errors 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_ERROR 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_ERROR 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:value:get"><apiName>value</apiName><shortdesc>
		 Always returns null since no values are associated with errors 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Always returns null since no values are associated with errors 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:ISubject"><apiName>ISubject</apiName><shortdesc>
	 A resource that is both observable and an observer
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseInterface>raix.reactive:IObserver</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 A resource that is both observable and an observer
	 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="raix.reactive:OnNext"><apiName>OnNext</apiName><shortdesc>
	 A Notification for an onNext call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onNext call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnNext:OnNext"><apiName>OnNext</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnNext:accept"><apiName>accept</apiName><shortdesc>
		 Calls onNext if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onNext if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnNext:error:get"><apiName>error</apiName><shortdesc>
		 Always returns false since no errors are associated with values 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Always returns false since no errors are associated with values 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns true 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns true 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_NEXT 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_NEXT 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:value:get"><apiName>value</apiName><shortdesc>
		 Gets the value from the message 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the value from the message 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:TimeoutError"><apiName>TimeoutError</apiName><shortdesc>
	 An error thrown by Observable.timeout by default
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
	 An error thrown by Observable.timeout by default
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeoutError:TimeoutError"><apiName>TimeoutError</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>id</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="raix.reactive:OnCompleted"><apiName>OnCompleted</apiName><shortdesc>
	 A Notification for an onCompleted call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onCompleted call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnCompleted:OnCompleted"><apiName>OnCompleted</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnCompleted:accept"><apiName>accept</apiName><shortdesc>
		 Calls onCompleted if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onCompleted if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnCompleted:error:get"><apiName>error</apiName><shortdesc>
		 Always returns false since no errors are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Always returns false since no errors are associated with completion 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns false since no values are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns false since no values are associated with completion 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_COMPLETED 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_COMPLETED 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:value:get"><apiName>value</apiName><shortdesc>
		 Always returns null since no values are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Always returns null since no values are associated with completion 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:AbsObservable"><apiName>AbsObservable</apiName><shortdesc>
	 Subclass this class only if you want to implement a completely custom IObservable.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Subclass this class only if you want to implement a completely custom IObservable.
	 
	 <p>If you can avoid it, however, try to stick to subclassing Subject or using 
	 one of the creation methods.</p>
	 
	 <p>This class may be made inaccessible in future revisions</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:AbsObservable:AbsObservable"><apiName>AbsObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:AbsObservable:aggregate"><apiName>aggregate</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:all"><apiName>all</apiName><shortdesc>
		 
		 Determines if all values in the source sequence satisfy a condition
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate that determines if a value in the sequence is valid. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if all values in the source sequence satisfy a condition
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:and"><apiName>and</apiName><shortdesc>
		  
		 Creates a pattern by combining the current source with right.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A pattern representing both sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence to combine with the pattern.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		  
		 Creates a pattern by combining the current source with right.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:any"><apiName>any</apiName><shortdesc>
		 
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The predicate that determines if a value in the sequence is valid. 
		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:asObservable"><apiName>asObservable</apiName><shortdesc>
		 
		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:average"><apiName>average</apiName><shortdesc>
		 
		 Returns the average value of all the elements in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TSource values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The selector function that returns a numeric value from the source value  
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the average value of all the elements in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithCount"><apiName>bufferWithCount</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of arrays of the the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithTimeOrCount"><apiName>bufferWithTimeOrCount</apiName><shortdesc>
		 
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time to buffer values for
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values to include in a single buffer
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithTime"><apiName>bufferWithTime</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Arrays of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:cast"><apiName>cast</apiName><shortdesc>
		 
		 Forces values from a source sequence to be of a specific class
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The valueClass of the output sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Forces values from a source sequence to be of a specific class
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:catchErrorDefer"><apiName>catchErrorDefer</apiName><shortdesc>
		 
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>errorClass</apiItemName><apiType value="Class"/><apiDesc>The class (and superclass) of error to act on
		 </apiDesc></apiParam><apiParam><apiItemName>deferFunc</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of an error. 
		 Signature is <codeph>function(e : Error) : IObservable</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:catchError"><apiName>catchError</apiName><shortdesc>
		 
		 Runs a specific sequence when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to when an error occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Runs a specific sequence when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:chain"><apiName>chain</apiName><shortdesc>
		 
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the values returned by the sequence returned by the last 
		 selector in the chain
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>functions</apiItemName><apiType value="Array"/><apiDesc>An array of functions that accept a value from the previous sequence and 
		        return a new sequence:
		        function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:combineLatest"><apiName>combineLatest</apiName><shortdesc>
		 
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of returnType 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that combines values from the two sources. Signature is <codeph>function(left : this.valueClass, right : right.valueClass) : returnType</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:concatMany"><apiName>concatMany</apiName><shortdesc>
		 
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to concatonate:
		     function(value:T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:concat"><apiName>concat</apiName><shortdesc>
		 
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequences to concatonate after the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:contains"><apiName>contains</apiName><shortdesc>
		 
		 Determines if the source sequence contains a specific value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to check against the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function used to compare values. Default equality will be used if comparer is null.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the source sequence contains a specific value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:count"><apiName>count</apiName><shortdesc>
		 
		 Returns the number of elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Returns the number of elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:delayUntil"><apiName>delayUntil</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dt</apiItemName><apiType value="Date"/></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.reactive:AbsObservable:delay"><apiName>delay</apiName><shortdesc>
		 
		 Delays all values in a sequences by a specified time 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, to delay
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to delay the values
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Delays all values in a sequences by a specified time 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:dematerialize"><apiName>dematerialize</apiName><shortdesc>
		 
		 Converts materialized values back into messages  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Converts materialized values back into messages  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:distinctUntilChanged"><apiName>distinctUntilChanged</apiName><shortdesc>
		 
		 Filters out consecutive duplicates from a source sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The function used to compare values. Default equality will be used if comparer is null.
		 function(x:TValue, y:TValue) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out consecutive duplicates from a source sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:expand"><apiName>expand</apiName><shortdesc>
		 
		 Recursively expands the values in the sequence using a selector function 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of all values emitted by any of the sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts values and returns an expanded sequence for them:
		     function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Recursively expands the values in the sequence using a selector function 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:filter"><apiName>filter</apiName><shortdesc>
		 
		 Filters out values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate function to execute for each value to determine if it will be include in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:finallyAction"><apiName>finallyAction</apiName><shortdesc>
		 
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event the sequence completes or errors
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:first"><apiName>first</apiName><shortdesc>
		 
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to, along with the current sequence
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that accepts the last values of both sequences and returns the output value:
		     function(left : TLeft, right : TRight) : TResult 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupByUntil"><apiName>groupByUntil</apiName><shortdesc>
		 
		 Groups values by a key and also provides a lifetime for a grouping
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>durationSelector</apiItemName><apiType value="Function"/><apiDesc>A selector that returns an observable sequence that will signal 
		     the end of the life of a group by emitting a value or completing:
		     function(group:IGroupedObservable) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Groups values by a key and also provides a lifetime for a grouping
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 
		 Groups values by a key
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Groups values by a key
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value
		 to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:ignoreValues"><apiName>ignoreValues</apiName><shortdesc>
		 
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:join"><apiName>join</apiName><shortdesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult (returned by joinSelector)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 
		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:last"><apiName>last</apiName><shortdesc>
		 
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:let"><apiName>let</apiName><shortdesc>
		 
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The observable sequence returned by func 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>func</apiItemName><apiType value="Function"/><apiDesc>The function to send the current sequence through, and return a new sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:log"><apiName>log</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>message</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence containing the values emitted from the child observable sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The valueClass of the sequences returned by selector
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:map"><apiName>map</apiName><shortdesc>
		 
		 Maps the values from a source sequence through a function to change their value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Maps the values from a source sequence through a function to change their value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:materialize"><apiName>materialize</apiName><shortdesc>
		 
		 Converts all messages (next, complete, error) into values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of rx.Notification
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Converts all messages (next, complete, error) into values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:mergeMany"><apiName>mergeMany</apiName><shortdesc>
		 
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to merge:
		     function(value:T) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:merge"><apiName>merge</apiName><shortdesc>
		 
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequences from which the values will be merged with the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multiWindow"><apiName>multiWindow</apiName><shortdesc>
		 
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowOpenings</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>Signals the start of a new window by emitting a value
		 </apiDesc></apiParam><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an observable sequence that will signal the close of a window:
		 function (window : IObservable) : IObservable 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multicastDefer"><apiName>multicastDefer</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains messages from the selector-returned sequence, piped 
		 through the subject supplied by subjectSelector
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subjectSelector</apiItemName><apiType value="Function"/><apiDesc>Determines the subject to be used when the sequence is subscribed to
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts the yet-to-be-connected connectable sequence and returns the sequence 
		 that will supply values to the subject
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time. The shared sequence will be passed 
		 to a selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multicast"><apiName>multicast</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subject</apiItemName><apiOperationClassifier>raix.reactive:ISubject</apiOperationClassifier><apiDesc>The subject that will messages and subscriptions
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:observeOn"><apiName>observeOn</apiName><shortdesc>
		 
		 Defers messages to subscribers through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to send messages to subscribers through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Defers messages to subscribers through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:ofClass"><apiName>ofClass</apiName><shortdesc>
		 
		 Filters out values from a source sequence that are not of a specific type 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The class (or subsclass) of all values to emit 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out values from a source sequence that are not of a specific type 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 
		 Subscribes down a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to run after the current sequence completes or errors
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to subscribe to the new sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes down a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:peekWith"><apiName>peekWith</apiName><shortdesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier><apiDesc>The observer that will receive messages
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:peek"><apiName>peek</apiName><shortdesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>nextAction</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of a value (onNext)
		 </apiDesc></apiParam><apiParam><apiItemName>completeAction</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event the sequence completes (onComplete)
		 </apiDesc></apiParam><apiParam><apiItemName>errorAction</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event of an error (onError)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:pruneDefer"><apiName>pruneDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:prune"><apiName>prune</apiName><shortdesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:publishDefer"><apiName>publishDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:publish"><apiName>publish</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:reduce"><apiName>reduce</apiName><shortdesc>
		  
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of type TAccumulate
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that accumulates the aggregate value: 
		     function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		  
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:removeTimeInterval"><apiName>removeTimeInterval</apiName><shortdesc>
		 
		 Removes time interval information added with timeInterval  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeInterval)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Removes time interval information added with timeInterval  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:removeTimestamp"><apiName>removeTimestamp</apiName><shortdesc>
		 
		 Removes timestamp information added with timestamp  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeStamp)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Removes timestamp information added with timestamp  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:repeat"><apiName>repeat</apiName><shortdesc>
		 
		 Repeats the source sequence a specific number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to repeat the sequence or 0 to repeat indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Repeats the source sequence a specific number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:replayDefer"><apiName>replayDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through 
		 </apiDesc></apiParam><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:replay"><apiName>replay</apiName><shortdesc>
		 
		 Records the output of the source sequence and replays it to future subscribers 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Records the output of the source sequence and replays it to future subscribers 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:retry"><apiName>retry</apiName><shortdesc>
		 
		 Repeats the source sequence when an error occurs 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>retryCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to retry the sequence in the event of an error, 
		 or 0 to retry indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Repeats the source sequence when an error occurs 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:sample"><apiName>sample</apiName><shortdesc>
		 
		 Emits the latest value on a time interval from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, to sample the current value after
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the latest value on a time interval from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:scan"><apiName>scan</apiName><shortdesc>
		 
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>The function that accumulates values
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:selectMany"><apiName>selectMany</apiName><shortdesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam><apiDeprecated replacement="mapMany"/></apiOperationDef><apiDesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:select"><apiName>select</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam><apiDeprecated replacement="map"/></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.reactive:AbsObservable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 
		 Determines whether two observable sequences are equal 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will emit a single boolean value once equality has been determined
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The observable sequence to compare to
		 </apiDesc></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The equality comparer to compare values between sequences:
		 function(value : TValue, otherValue : TOther) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines whether two observable sequences are equal 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:single"><apiName>single</apiName><shortdesc>
		 
		 Emits the only item from a source sequence, or an error if any other number of values are emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 
		 Ignores a set number of values from the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores a set number of values from the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipUntil"><apiName>skipUntil</apiName><shortdesc>
		 
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the start of values being used from the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 
		 Ignores values from a source sequence until a condition is no longer met
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores values from a source sequence until a condition is no longer met
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skip"><apiName>skip</apiName><shortdesc>
		 
		 Ignores a set number of values from the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores a set number of values from the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:startWith"><apiName>startWith</apiName><shortdesc>
		 
		 Emits the specified values at the start of a sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="any"/><apiDesc>That value, converted to an IObservable using toObservable, that will 
		 be emitted at the start of the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the specified values at the start of a sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribeOn"><apiName>subscribeOn</apiName><shortdesc>
		 
		 Defers subscriptions to the source through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to schedule subscriptions through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Defers subscriptions to the source through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribe"><apiName>subscribe</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied functions 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>Function to be called for every value. Signature is <codeph>function(payload : T) : void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onComplete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when the sequence completes. Signature is <codeph>function():void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when an error occurs in the sequence. Signature is <codeph>function(err:Error):void</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied functions 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:sum"><apiName>sum</apiName><shortdesc>
		 
		 Returns the summed value of all the elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Number
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Returns the summed value of all the elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:switchMany"><apiName>switchMany</apiName><shortdesc>
		 
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiOperationDef><apiDesc>
		 
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 
		 Takes only the last set number of values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes only the last set number of values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeUntil"><apiName>takeUntil</apiName><shortdesc>
		 
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the end of values being used from the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 
		 Takes values from a source sequence until a condition is no longer met 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes values from a source sequence until a condition is no longer met 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:take"><apiName>take</apiName><shortdesc>
		 
		 Takes only the first set number of values from a source sequenc
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes only the first set number of values from a source sequenc
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:then"><apiName>then</apiName><shortdesc>
		 
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.join
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The function that will accept this sequence as an argument
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:throttle"><apiName>throttle</apiName><shortdesc>
		 
		 Limits how often values from a source sequence will be accepted from a source
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dueTimeMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, during which only one value from the source sequence will be accepted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Limits how often values from a source sequence will be accepted from a source
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timeInterval"><apiName>timeInterval</apiName><shortdesc>
		 
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TimeInterval
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to determine time
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timeout"><apiName>timeout</apiName><shortdesc>
		 
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeoutMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, after which to raise an error (or subscribe to other)
		 </apiDesc></apiParam><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiData>null</apiData><apiDesc>The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timestamp"><apiName>timestamp</apiName><shortdesc>
		 
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Timestamped 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:toArray"><apiName>toArray</apiName><shortdesc>
		 
		 Delivers all the results as a single array when the source completes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Array that will contain the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Delivers all the results as a single array when the source completes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithCount"><apiName>windowWithCount</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithTimeOrCount"><apiName>windowWithTimeOrCount</apiName><shortdesc>
		 
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time for a child-sequence to capture values
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values for a child-sequence to capture
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithTime"><apiName>windowWithTime</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:window"><apiName>window</apiName><shortdesc>
		 
		 Splits values into child-observable windows which are closed by the caller
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an IObservable that will emit a value or complete to indicate that the active 
		 		  window has closed. Called on subscription and immediately after each window closes. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Splits values into child-observable windows which are closed by the caller
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:zip"><apiName>zip</apiName><shortdesc>
		 
		 Merges two sequences through a mapping function while only ever using each value once 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>rightSource</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with the current
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed when values are received from both sequences. The return value will be included in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Merges two sequences through a mapping function while only ever using each value once 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:CompositeCancelable"><apiName>CompositeCancelable</apiName><shortdesc>
	 Represents a cancelable resource that controls multiple 
	 other cancelable resources 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a cancelable resource that controls multiple 
	 other cancelable resources 
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:CompositeCancelable:CompositeCancelable"><apiName>CompositeCancelable</apiName><shortdesc>
		 Creates a composite cancelable instance with the cancelable 
		 instances to start with
		 </shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>values</apiItemName><apiType value="Array"/><apiData>null</apiData></apiParam></apiConstructorDef><apiDesc>
		 Creates a composite cancelable instance with the cancelable 
		 instances to start with
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:CompositeCancelable:add"><apiName>add</apiName><shortdesc>
		 Adds a cancelable resource to the list of cancelable resources.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>cancelable</apiItemName><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Adds a cancelable resource to the list of cancelable resources. If 
		 this instance has already been canceled, the resource will be immediately 
		 canceled and not added to the list.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:CompositeCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels (and removes) all resources in this instance
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels (and removes) all resources in this instance
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:CompositeCancelable:remove"><apiName>remove</apiName><shortdesc>
		 Removes a cancelable resource from the list
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>cancelable</apiItemName><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Removes a cancelable resource from the list
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:CompositeCancelable:cancelables:get"><apiName>cancelables</apiName><shortdesc>
		 Gets the list of cancelable resources in this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef><apiDesc>
		 Gets the list of cancelable resources in this instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:CompositeCancelable:count:get"><apiName>count</apiName><shortdesc>
		 Gets the number of resources in this list
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="uint"/></apiValueDef><apiDesc>
		 Gets the number of resources in this list
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Subject"><apiName>Subject</apiName><shortdesc>
	 A Subject is both an IObservable and an IObserver, so it can be 
	 returned as an IObservable and fed values through the IObserver 
	 methods.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ISubject</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Subject is both an IObservable and an IObserver, so it can be 
	 returned as an IObservable and fed values through the IObserver 
	 methods.
	 
	 <p>When returning a Subject as an IObservable, it's recommended that you
	 return subject.asObservable() to hide the original instance</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Subject:Subject"><apiName>Subject</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Subject:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:onError"><apiName>onError</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:onNext"><apiName>onNext</apiName><shortdesc>
		 
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pl</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Subject:hasSubscriptions:get"><apiName>hasSubscriptions</apiName><shortdesc>
		 Determines whether this subject has any subscriptions
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determines whether this subject has any subscriptions
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Subject:subscriptionCount:get"><apiName>subscriptionCount</apiName><shortdesc>
		 Gets the number of subscriptions this subject has
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Gets the number of subscriptions this subject has
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Cancelable"><apiName>Cancelable</apiName><shortdesc>
	 Provides static methods that create cancelable resources
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create cancelable resources
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Cancelable:Cancelable"><apiName>Cancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Cancelable:create"><apiName>create</apiName><shortdesc>
		 Creates a cancelable resource that calls a function when canceled
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call when the resource is canceled 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a cancelable resource that calls a function when canceled
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Cancelable:empty:get"><apiName>empty</apiName><shortdesc>
		 Returns a cancelable resource that does nothing when canceled
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive:ICancelable</apiValueClassifier></apiValueDef><apiDesc>
		 Returns a cancelable resource that does nothing when canceled
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:IObservable"><apiName>IObservable</apiName><shortdesc>
	 An observable (or "push"), sequence of values that often represent data or events that have not yet occured.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An observable (or "push"), sequence of values that often represent data or events that have not yet occured. 
	 Sequences can be manipulated, often combining them with other sequences, and then subscribed to 
	 to receive the output.
	 
	 Chains of sequences are automatically torn down when the sequence completes, errors or is unsubscribed from.
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:aggregate"><apiName>aggregate</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam><apiDeprecated replacement="reduce"/></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:all"><apiName>all</apiName><shortdesc>
		 Determines if all values in the source sequence satisfy a condition
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate that determines if a value in the sequence is valid. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if all values in the source sequence satisfy a condition
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:and"><apiName>and</apiName><shortdesc> 
		 Creates a pattern by combining the current source with right.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A pattern representing both sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence to combine with the pattern.
		 </apiDesc></apiParam></apiOperationDef><apiDesc> 
		 Creates a pattern by combining the current source with right.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:any"><apiName>any</apiName><shortdesc>
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The predicate that determines if a value in the sequence is valid. 
		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:asObservable"><apiName>asObservable</apiName><shortdesc>
		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Hides the source sequence so it cannot be cast back to it’s concrete implementation  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:average"><apiName>average</apiName><shortdesc>
		 Returns the average value of all the elements in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TSource values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The selector function that returns a numeric value from the source value  
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the average value of all the elements in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithCount"><apiName>bufferWithCount</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of arrays of the the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithTimeOrCount"><apiName>bufferWithTimeOrCount</apiName><shortdesc>
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time to buffer values for
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values to include in a single buffer
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithTime"><apiName>bufferWithTime</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Arrays of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:cast"><apiName>cast</apiName><shortdesc>
		 Forces values from a source sequence to be of a specific class
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The valueClass of the output sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Forces values from a source sequence to be of a specific class
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:catchErrorDefer"><apiName>catchErrorDefer</apiName><shortdesc>
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>errorClass</apiItemName><apiType value="Class"/><apiDesc>The class (and superclass) of error to act on
		 </apiDesc></apiParam><apiParam><apiItemName>deferFunc</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of an error. 
		 Signature is <codeph>function(e : Error) : IObservable</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:catchError"><apiName>catchError</apiName><shortdesc>
		 Runs a specific sequence when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to when an error occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Runs a specific sequence when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:chain"><apiName>chain</apiName><shortdesc>
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the values returned by the sequence returned by the last 
		 selector in the chain
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>functions</apiItemName><apiType value="Array"/><apiDesc>An array of functions that accept a value from the previous sequence and 
		        return a new sequence:
		        function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:combineLatest"><apiName>combineLatest</apiName><shortdesc>
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of returnType 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that combines values from the two sources. Signature is <codeph>function(left : this.valueClass, right : right.valueClass) : returnType</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:concatMany"><apiName>concatMany</apiName><shortdesc>
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to concatonate:
		     function(value:T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:concat"><apiName>concat</apiName><shortdesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequences to concatonate after the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:contains"><apiName>contains</apiName><shortdesc>
		 Determines if the source sequence contains a specific value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to check against the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function used to compare values. Default equality will be used if comparer is null.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the source sequence contains a specific value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:count"><apiName>count</apiName><shortdesc>
		 Returns the number of elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns the number of elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:delay"><apiName>delay</apiName><shortdesc>
		 Delays all values in a sequences by a specified time 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, to delay
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to delay the values
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Delays all values in a sequences by a specified time 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:dematerialize"><apiName>dematerialize</apiName><shortdesc>
		 Converts materialized values back into messages  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Converts materialized values back into messages  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:distinctUntilChanged"><apiName>distinctUntilChanged</apiName><shortdesc>
		 Filters out consecutive duplicates from a source sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The function used to compare values. Default equality will be used if comparer is null.
		 function(x:TValue, y:TValue) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out consecutive duplicates from a source sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:expand"><apiName>expand</apiName><shortdesc>
		 Recursively expands the values in the sequence using a selector function 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of all values emitted by any of the sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts values and returns an expanded sequence for them:
		     function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Recursively expands the values in the sequence using a selector function 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:filter"><apiName>filter</apiName><shortdesc>
		 Filters out values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate function to execute for each value to determine if it will be include in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:finallyAction"><apiName>finallyAction</apiName><shortdesc>
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>finallyAction</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event the sequence completes or errors
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:first"><apiName>first</apiName><shortdesc>
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to, along with the current sequence
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that accepts the last values of both sequences and returns the output value:
		     function(left : TLeft, right : TRight) : TResult 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupByUntil"><apiName>groupByUntil</apiName><shortdesc>
		 Groups values by a key and also provides a lifetime for a grouping
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>durationSelector</apiItemName><apiType value="Function"/><apiDesc>A selector that returns an observable sequence that will signal 
		     the end of the life of a group by emitting a value or completing:
		     function(group:IGroupedObservable) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Groups values by a key and also provides a lifetime for a grouping
		 </apiDesc></apiOperationDetail><related-links><link href="raix.reactive.xml#IGroupedObservable"><linktext>raix.reactive.IGroupedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 Groups values by a key
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Groups values by a key
		 </apiDesc></apiOperationDetail><related-links><link href="raix.reactive.xml#IGroupedObservable"><linktext>raix.reactive.IGroupedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value
		 to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:ignoreValues"><apiName>ignoreValues</apiName><shortdesc>
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:join"><apiName>join</apiName><shortdesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult (returned by joinSelector)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 
		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:last"><apiName>last</apiName><shortdesc>
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:let"><apiName>let</apiName><shortdesc>
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The observable sequence returned by func 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>func</apiItemName><apiType value="Function"/><apiDesc>The function to send the current sequence through, and return a new sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:log"><apiName>log</apiName><shortdesc>
		 Writes sequence activity out to the trace log with a message describing the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>message</apiItemName><apiType value="String"/><apiDesc>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Writes sequence activity out to the trace log with a message describing the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence containing the values emitted from the child observable sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The valueClass of the sequences returned by selector
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:map"><apiName>map</apiName><shortdesc>
		 Maps the values from a source sequence through a function to change their value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Maps the values from a source sequence through a function to change their value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:materialize"><apiName>materialize</apiName><shortdesc>
		 Converts all messages (next, complete, error) into values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of rx.Notification
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Converts all messages (next, complete, error) into values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:mergeMany"><apiName>mergeMany</apiName><shortdesc>
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to merge:
		     function(value:T) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiOperationDef><apiDesc>
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:merge"><apiName>merge</apiName><shortdesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequences from which the values will be merged with the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multiWindow"><apiName>multiWindow</apiName><shortdesc>
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowOpenings</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>Signals the start of a new window by emitting a value
		 </apiDesc></apiParam><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an observable sequence that will signal the close of a window:
		 function (window : IObservable) : IObservable 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multicastDefer"><apiName>multicastDefer</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains messages from the selector-returned sequence, piped 
		 through the subject supplied by subjectSelector
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subjectSelector</apiItemName><apiType value="Function"/><apiDesc>Determines the subject to be used when the sequence is subscribed to
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts the yet-to-be-connected connectable sequence and returns the sequence 
		 that will supply values to the subject
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time. The shared sequence will be passed 
		 to a selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multicast"><apiName>multicast</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subject</apiItemName><apiOperationClassifier>raix.reactive:ISubject</apiOperationClassifier><apiDesc>The subject that will messages and subscriptions
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:observeOn"><apiName>observeOn</apiName><shortdesc>
		 Defers messages to subscribers through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to send messages to subscribers through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers messages to subscribers through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:ofClass"><apiName>ofClass</apiName><shortdesc>
		 Filters out values from a source sequence that are not of a specific type 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The class (or subsclass) of all values to emit 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out values from a source sequence that are not of a specific type 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 Subscribes down a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to run after the current sequence completes or errors
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to subscribe to the new sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes down a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:peekWith"><apiName>peekWith</apiName><shortdesc>
		 Allows custom code to be run when messages arrive without affecting the observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier><apiDesc>The observer that will receive messages
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Allows custom code to be run when messages arrive without affecting the observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:peek"><apiName>peek</apiName><shortdesc>
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>next</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of a value (onNext)
		 </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event the sequence completes (onComplete)
		 </apiDesc></apiParam><apiParam><apiItemName>error</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event of an error (onError)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:pruneDefer"><apiName>pruneDefer</apiName><shortdesc>
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:prune"><apiName>prune</apiName><shortdesc>
		 Creates a shared sequence that emits the last value of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that emits the last value of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:publishDefer"><apiName>publishDefer</apiName><shortdesc>
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:publish"><apiName>publish</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:reduce"><apiName>reduce</apiName><shortdesc> 
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of type TAccumulate
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that accumulates the aggregate value: 
		     function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc> 
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:removeTimeInterval"><apiName>removeTimeInterval</apiName><shortdesc>
		 Removes time interval information added with timeInterval  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeInterval)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Removes time interval information added with timeInterval  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:removeTimestamp"><apiName>removeTimestamp</apiName><shortdesc>
		 Removes timestamp information added with timestamp  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeStamp)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Removes timestamp information added with timestamp  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:repeat"><apiName>repeat</apiName><shortdesc>
		 Repeats the source sequence a specific number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to repeat the sequence or 0 to repeat indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats the source sequence a specific number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:replayDefer"><apiName>replayDefer</apiName><shortdesc>
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through 
		 </apiDesc></apiParam><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:replay"><apiName>replay</apiName><shortdesc>
		 Records the output of the source sequence and replays it to future subscribers 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Records the output of the source sequence and replays it to future subscribers 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:retry"><apiName>retry</apiName><shortdesc>
		 Repeats the source sequence when an error occurs 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>retryCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to retry the sequence in the event of an error, 
		 or 0 to retry indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats the source sequence when an error occurs 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sample"><apiName>sample</apiName><shortdesc>
		 Emits the latest value on a time interval from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, to sample the current value after
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the latest value on a time interval from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:scan"><apiName>scan</apiName><shortdesc>
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>The function that accumulates values
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:selectMany"><apiName>selectMany</apiName><shortdesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam><apiDeprecated replacement="mapMany"/></apiOperationDef><apiDesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 Determines whether two observable sequences are equal 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will emit a single boolean value once equality has been determined
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The observable sequence to compare to
		 </apiDesc></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The equality comparer to compare values between sequences:
		 function(value : TValue, otherValue : TOther) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines whether two observable sequences are equal 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:single"><apiName>single</apiName><shortdesc>
		 Emits the only item from a source sequence, or an error if any other number of values are emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 Ignores a set number of values from the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores a set number of values from the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipUntil"><apiName>skipUntil</apiName><shortdesc>
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the start of values being used from the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 Ignores values from a source sequence until a condition is no longer met
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores values from a source sequence until a condition is no longer met
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skip"><apiName>skip</apiName><shortdesc>
		 Ignores a set number of values from the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores a set number of values from the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:startWith"><apiName>startWith</apiName><shortdesc>
		 Emits the specified values at the start of a sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="any"/><apiDesc>That value, converted to an IObservable using toObservable, that will 
		 be emitted at the start of the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the specified values at the start of a sequence 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.reactive.toObservable.xml"><linktext>raix.reactive.toObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribeOn"><apiName>subscribeOn</apiName><shortdesc>
		 Defers subscriptions to the source through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to schedule subscriptions through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers subscriptions to the source through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribe"><apiName>subscribe</apiName><shortdesc>
		 Subscribes to this observable using the supplied functions 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>Function to be called for every value. Signature is <codeph>function(payload : T) : void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onComplete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when the sequence completes. Signature is <codeph>function():void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when an error occurs in the sequence. Signature is <codeph>function(err:Error):void</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes to this observable using the supplied functions 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sum"><apiName>sum</apiName><shortdesc>
		 Returns the summed value of all the elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Number
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns the summed value of all the elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:switchMany"><apiName>switchMany</apiName><shortdesc>
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiOperationDef><apiDesc>
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 Takes only the last set number of values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes only the last set number of values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeUntil"><apiName>takeUntil</apiName><shortdesc>
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the end of values being used from the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 Takes values from a source sequence until a condition is no longer met 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes values from a source sequence until a condition is no longer met 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:take"><apiName>take</apiName><shortdesc>
		 Takes only the first set number of values from a source sequenc
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes only the first set number of values from a source sequenc
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:then"><apiName>then</apiName><shortdesc>
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.join
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The function that will accept this sequence as an argument
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:throttle"><apiName>throttle</apiName><shortdesc>
		 Limits how often values from a source sequence will be accepted from a source
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dueTimeMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, during which only one value from the source sequence will be accepted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Limits how often values from a source sequence will be accepted from a source
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timeInterval"><apiName>timeInterval</apiName><shortdesc>
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TimeInterval
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to determine time
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timeout"><apiName>timeout</apiName><shortdesc>
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeoutMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, after which to raise an error (or subscribe to other)
		 </apiDesc></apiParam><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiData>null</apiData><apiDesc>The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timestamp"><apiName>timestamp</apiName><shortdesc>
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Timestamped 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:toArray"><apiName>toArray</apiName><shortdesc>
		 Delivers all the results as a single array when the source completes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Array that will contain the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Delivers all the results as a single array when the source completes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithCount"><apiName>windowWithCount</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithTimeOrCount"><apiName>windowWithTimeOrCount</apiName><shortdesc>
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time for a child-sequence to capture values
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values for a child-sequence to capture
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithTime"><apiName>windowWithTime</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:window"><apiName>window</apiName><shortdesc>
		 Splits values into child-observable windows which are closed by the caller
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an IObservable that will emit a value or complete to indicate that the active 
		 		  window has closed. Called on subscription and immediately after each window closes. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Splits values into child-observable windows which are closed by the caller
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:zip"><apiName>zip</apiName><shortdesc>
		 Merges two sequences through a mapping function while only ever using each value once 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>rightSource</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with the current
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed when values are received from both sequences. The return value will be included in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Merges two sequences through a mapping function while only ever using each value once 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:Notification"><apiName>Notification</apiName><shortdesc>
	 Represents one of the three messages that can be sent to 
	 an observer.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents one of the three messages that can be sent to 
	 an observer.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="rx.OnNext.xml"><linktext>rx.OnNext</linktext></link><link href="" invalidHref="rx.OnCompleted.xml"><linktext>rx.OnCompleted</linktext></link><link href="" invalidHref="rx.OnError.xml"><linktext>rx.OnError</linktext></link></related-links><apiConstructor id="raix.reactive:Notification:Notification"><apiName>Notification</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Notification:acceptWith"><apiName>acceptWith</apiName><shortdesc>
		 Calls the appropriate method on an observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Calls the appropriate method on an observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Notification:accept"><apiName>accept</apiName><shortdesc>
		 Calls the appropriate method
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls the appropriate method
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Notification:error:get"><apiName>error</apiName><shortdesc>
		 Gets the error associated with this message or null if there is no error.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Gets the error associated with this message or null if there is no error.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Determined whether this instance has a value property available
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determined whether this instance has a value property available
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:kind:get"><apiName>kind</apiName><shortdesc>
		 Gets the NotificationKind of this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Gets the NotificationKind of this instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:value:get"><apiName>value</apiName><shortdesc>
		 Gets the value associated with this message
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the value associated with this message
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Observable"><apiName>Observable</apiName><shortdesc>
	 Provides static methods that create IObservable sequences
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create IObservable sequences
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Observable:Observable"><apiName>Observable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Observable:amb"><apiName>amb</apiName><shortdesc>
		 Takes multiple source sequences and returns values from the first sequence to emit a value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of the same valueClass as the first sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The sources that will be subscribed to
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes multiple source sequences and returns values from the first sequence to emit a value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:catchErrors"><apiName>catchErrors</apiName><shortdesc>
		 Concatonates a list of sequences as each one errors.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence with the valueClass of the first sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The list of sequence to concatonate.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates a list of sequences as each one errors. A successful sequence ends the concatonation.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:concat"><apiName>concat</apiName><shortdesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="any"/><apiDesc>Anything that can be converted to an IObservable of IObservables using toObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:createWithCancelable"><apiName>createWithCancelable</apiName><shortdesc>
		 Creates a custom observable sequence that uses cancelable resources  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscribeFunc</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a subscriber subscribes, the return value of which is an ICancelable to be canceled when the sequence is terminated
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence that uses cancelable resources  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:create"><apiName>create</apiName><shortdesc>
		 Creates a custom observable sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscribeFunc</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a subscriber subscribes, the return value of which is a function to be run when the sequence is terminated
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:defer"><apiName>defer</apiName><shortdesc>
		 Defers selection of a sequence until the sequence is subscribed to  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observableFactory</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a new subscription occurs, the returned sequence will be used for the subscriber.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of a sequence until the sequence is subscribed to  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:empty"><apiName>empty</apiName><shortdesc>
		 Creates a sequence that immediately completes  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that immediately completes  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:error"><apiName>error</apiName><shortdesc>
		 Creates a sequence that immediately throws an Error  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>err</apiItemName><apiType value="Error"/><apiDesc>The error to raise when a new subscription occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that immediately throws an Error  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 Subscribes to multiple source sequence and emits the last values of each after all have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of Array
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The sequences to subscribe to
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes to multiple source sequence and emits the last values of each after all have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromArray"><apiName>fromArray</apiName><shortdesc>
		 Creates a sequence consisting of the values in an Array 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of elementClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>values</apiItemName><apiType value="Array"/><apiDesc>The array of values to iterate through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence consisting of the values in an Array 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromErrorEvents"><apiName>fromErrorEvents</apiName><shortdesc>
		 Creates a sequence that emits an error when one of several event valueClasss is received from an IEventDispatcher
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventTypes</apiItemName><apiType value="Array"/><apiDesc>The event types that signify an error
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam><apiParam><apiItemName>errorMap</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function that maps an event to an Error. null can be used if the event will be ErrorEvent
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that emits an error when one of several event valueClasss is received from an IEventDispatcher
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromErrorEvent"><apiName>fromErrorEvent</apiName><shortdesc>
		 Creates a sequence that emits an error when an event is received from an IEventDispatcher  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass, or Object if valueClass is null 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventType</apiItemName><apiType value="String"/><apiDesc>The event type
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam><apiParam><apiItemName>errorMap</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function that maps an event to an Error. null can be used if the event will be ErrorEvent
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that emits an error when an event is received from an IEventDispatcher  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromEvents"><apiName>fromEvents</apiName><shortdesc>
		 Creates Combines events from multiple event valueClasss 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of commonValueClass, or Event if commonValueClass is null 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventTypes</apiItemName><apiType value="Array"/><apiDesc>An array event type names
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates Combines events from multiple event valueClasss 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromEvent"><apiName>fromEvent</apiName><shortdesc>
		 Creates a sequence of events from an IEventDispatcher 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of eventType, or Event if eventType is null
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventType</apiItemName><apiType value="String"/><apiDesc>The valueClass of event dispatched by eventDispatcher. Event will be used if this argument is null.
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence of events from an IEventDispatcher 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:generate"><apiName>generate</apiName><shortdesc>
		 Creates a custom observable sequence that is controlled by methods supplied as arguments 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>initialState</apiItemName><apiType value="Object"/><apiDesc>The initial state value to use (of class valueClass)
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate to determine whether the sequence has completed
		 </apiDesc></apiParam><apiParam><apiItemName>iterate</apiItemName><apiType value="Function"/><apiDesc>The function executed between iterations
		 </apiDesc></apiParam><apiParam><apiItemName>resultMap</apiItemName><apiType value="Function"/><apiDesc>The function that maps the current state to an output value
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence that is controlled by methods supplied as arguments 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:ifElse"><apiName>ifElse</apiName><shortdesc>
		 Defers selection of one of two sequences until the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to execute when a subscription occurs to determine which sequence to subscribe to
		 </apiDesc></apiParam><apiParam><apiItemName>ifTrue</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to if predicate returns true
		 </apiDesc></apiParam><apiParam><apiItemName>ifFalse</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to if predicate returns false
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of one of two sequences until the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:interval"><apiName>interval</apiName><shortdesc>
		 Creates an unending observable sequence of integers that are incremented at a regular interval 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait in between values
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used for timing
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an unending observable sequence of integers that are incremented at a regular interval 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:lookup"><apiName>lookup</apiName><shortdesc>
		 Defers selection of the sequence to use by using a function that returns a key into a dictionary of sequences 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>The function that, at the moment of subscription, will return the key into dictionary
		 </apiDesc></apiParam><apiParam><apiItemName>dictionary</apiItemName><apiType value="flash.utils:Dictionary"/><apiDesc>The dictionary of sequences
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of the sequence to use by using a function that returns a key into a dictionary of sequences 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:merge"><apiName>merge</apiName><shortdesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="any"/><apiDesc>Either an array of IObservable or an IObservable of IObservables
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.reactive.toObservable.xml"><linktext>raix.reactive.toObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:Observable:never"><apiName>never</apiName><shortdesc>
		 Returns an IObservable that never completes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns an IObservable that never completes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 Concatonates a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of the valueClass of the value sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The list of sequences to concatonate
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:range"><apiName>range</apiName><shortdesc>
		 Creates a sequence of consecutive integers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>start</apiItemName><apiType value="int"/><apiDesc>The inclusive start value of the range
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values, including start, to emit
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence of consecutive integers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:repeatValue"><apiName>repeatValue</apiName><shortdesc>
		 Repeats a value a specification number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiType value="Object"/><apiDesc>The value to repeat
		 </apiDesc></apiParam><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to emit the value
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats a value a specification number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:start"><apiName>start</apiName><shortdesc>
		 Creates a sequence based on a call to a function  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence based on a call to a function  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:timer"><apiName>timer</apiName><shortdesc>
		 Creates an unending observable sequence of integers that begin after a delay and are incremented at a regular interval 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait before the first value
		 </apiDesc></apiParam><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait in between subsequent values
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used for timing
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an unending observable sequence of integers that begin after a delay and are incremented at a regular interval 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:toAsync"><apiName>toAsync</apiName><shortdesc>
		 Converts a function into an observable sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A function accepting the arguments of the original action, but that will 
		 return an IObservable when called.
		 </apiDesc><apiType value="Function"/></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Converts a function into an observable sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:uncaughtErrors"><apiName>uncaughtErrors</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>loaderInfo</apiItemName><apiType value="flash.display:LoaderInfo"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:urlLoader"><apiName>urlLoader</apiName><shortdesc>
		 Creates an observable sequence that loads an object from a URLRequest 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of Object
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>request</apiItemName><apiType value="flash.net:URLRequest"/><apiDesc>The URLRequest to load
		 </apiDesc></apiParam><apiParam><apiItemName>dataFormat</apiItemName><apiType value="String"/><apiData>text</apiData><apiDesc>A value of flash.net.URLLoaderDataFormat
		 </apiDesc></apiParam><apiParam><apiItemName>loaderContext</apiItemName><apiType value="flash.system:LoaderContext"/><apiData>null</apiData><apiDesc>The optional LoaderContext to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an observable sequence that loads an object from a URLRequest 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:value"><apiName>value</apiName><shortdesc>
		 Create a sequence consisting of exactly one value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiType value="Object"/><apiDesc>The value to emit
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Create a sequence consisting of exactly one value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:when"><apiName>when</apiName><shortdesc>
		 Matches multiple plans (source sequence combinations) in the order they are specified 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>plans</apiItemName><apiType value="Array"/><apiDesc>The array of rx.Plan objects creates using 'and' and 'then'
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Matches multiple plans (source sequence combinations) in the order they are specified 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:xml"><apiName>xml</apiName><shortdesc>
		 Loads an XML document
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IObservable sequence of XMLDocument 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>request</apiItemName><apiType value="flash.net:URLRequest"/><apiDesc>The URLRequest to load
		 </apiDesc></apiParam><apiParam><apiItemName>loaderContext</apiItemName><apiType value="flash.system:LoaderContext"/><apiData>null</apiData><apiDesc>Whether to ignore whitespace when parsing the XML
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Loads an XML document
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Observable:maxConcurrentLoaders:get"><apiName>maxConcurrentLoaders</apiName><shortdesc>
		 Gets the maximum number of urlLoaders that can execute concurrently.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="uint"/></apiValueDef><apiDesc>
		 Gets the maximum number of urlLoaders that can execute concurrently. The value 
		 defaults to 2 to prevent issues in some browers. 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:ICancelable"><apiName>ICancelable</apiName><shortdesc>
	 Represents a handle that can be used to cancel an operation 
	 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Represents a handle that can be used to cancel an operation 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="raix.reactive.CompositeCancelable,.xml"><linktext>raix.reactive.BooleanCancelable, raix.reactive.FutureCancelable, raix.reactive.Cancelable</linktext></link></related-links><apiOperation id="raix.reactive:ICancelable:raix.reactive:ICancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:NotificationKind"><apiName>NotificationKind</apiName><shortdesc>
	 Enumeration for the different types of Notification
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Enumeration for the different types of Notification
	 </apiDesc></apiClassifierDetail><apiValue id="raix.reactive:NotificationKind:ON_COMPLETED"><apiName>ON_COMPLETED</apiName><shortdesc>
		 An onCompleted message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onCompleted message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnCompleted.xml"><linktext>rx.OnCompleted</linktext></link></related-links></apiValue><apiValue id="raix.reactive:NotificationKind:ON_ERROR"><apiName>ON_ERROR</apiName><shortdesc>
		 An onError message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onError message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnError.xml"><linktext>rx.OnError</linktext></link></related-links></apiValue><apiValue id="raix.reactive:NotificationKind:ON_NEXT"><apiName>ON_NEXT</apiName><shortdesc>
		 An onNext (value) message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onNext (value) message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnNext.xml"><linktext>rx.OnNext</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:raix.reactive:toObservable"><apiName>toObservable</apiName><shortdesc>
	 Converts a value to an IObservable sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/></apiParam></apiOperationDef><apiDesc>
	 Converts a value to an IObservable sequence. It can be considered to have the following overloads:
	 
	 <ul>
	 <li>function():IObservable - returns an empty sequence</li>
	 <li>function(array : Array):Observable - returns a sequence that wraps an array</li>
	 <li>function(observable : IObservable):IObservable - returns observable</li>
	 <li>function(enumerable : IEnumerable):IObservable - returns a sequence that wraps eumerable</li>
	 <li>function(error : Error):IObservable - returns a sequence will error when subscribed to</li>
	 <li>function(value : :IEnumerable - returns enumerable that contains a single value</li>
	 </ul>
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="raix.reactive:Pattern"><apiName>Pattern</apiName><shortdesc>
	 A combination of multiple IObservable sequences that can be combined 
	 into a Plan
	 
	 Generally, a Pattern will be created using IObservable.and or 
	 Pattern.and(), rather than creating a Pattern directly
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A combination of multiple IObservable sequences that can be combined 
	 into a Plan
	 
	 <p>Generally, a Pattern will be created using IObservable.and or 
	 Pattern.and(), rather than creating a Pattern directly</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Pattern:Pattern"><apiName>Pattern</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Pattern:and"><apiName>and</apiName><shortdesc>
		 Creates another pattern that combines the IObservable sequences 
		 of this Pattern with another IObservable sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Pattern with the new set of sequences
		 
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The IObservable sequence to add
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates another pattern that combines the IObservable sequences 
		 of this Pattern with another IObservable sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Pattern:then"><apiName>then</apiName><shortdesc>
		 Creates a Plan from this Pattern, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.when
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The valueClass that will be returned by thenFunction
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a Plan from this Pattern, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:IObserver"><apiName>IObserver</apiName><shortdesc>
	 An object that receives messages from an IObservable sequence
	 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An object that receives messages from an IObservable sequence
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="raix.reactive.xml#Observer"><linktext>Observer</linktext></link></related-links><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onError"><apiName>onError</apiName><shortdesc>
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onNext"><apiName>onNext</apiName><shortdesc>
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:Plan"><apiName>Plan</apiName><shortdesc>
	 A combination of IObservable sequences and a selector that will 
	 map the values of those sequences to an output value.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A combination of IObservable sequences and a selector that will 
	 map the values of those sequences to an output value. A plan is intended 
	 to be used with Observable.when
	 
	 <p>Generally, a Plan will be created using Pattern.then(), rather 
	 than creating a Plan directly</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Plan:Plan"><apiName>Plan</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:Plan:selector:get"><apiName>selector</apiName><shortdesc>
		 Gets the function selector that will accept one argument for each 
		 sequence in sources and return the output value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef><apiDesc>
		 Gets the function selector that will accept one argument for each 
		 sequence in sources and return the output value
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Plan:sources:get"><apiName>sources</apiName><shortdesc>
		 Gets the observable sequences in this plan
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef><apiDesc>
		 Gets the observable sequences in this plan
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>